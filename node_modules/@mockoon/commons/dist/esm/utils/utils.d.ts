import { Environment } from '../models/environment.model';
import { Folder, FolderChild } from '../models/folder.model';
import { Header, Route, RouteResponse, RouteType } from '../models/route.model';
/**
 * Deduplicate slashes in a string
 *
 * @param str
 * @returns
 */
export declare const dedupSlashes: (str: string) => string;
/**
 * Extract the content-type from an array of headers
 *
 * @param headers
 */
export declare const GetContentType: (headers: Header[]) => string | null;
/**
 * Return a route response's content-type.
 * Environment's content-type is overridden by route's content-type
 *
 * @param environment
 * @param routeResponse
 */
export declare const GetRouteResponseContentType: (environment: Environment, routeResponse: RouteResponse) => string;
export declare const GetResponseCallbackContentType: (environment: Environment, routeResponse: RouteResponse) => string;
/**
 * Test if URL is valid
 *
 * @param URL
 */
export declare const IsValidURL: (address: string) => boolean;
/**
 * Clone an object using JSON.stringify
 * /!\ Suitable for Environment, Route, etc but not for complex objects containing Map, Set, etc
 */
export declare const CloneObject: <T>(objectToClone: T) => T;
/**
 * Compare two objects using JSON.Stringify
 */
export declare const IsEqual: <T = unknown>(firstObject: T, secondObject: T) => boolean;
export declare const RemoveLeadingSlash: (str: string) => string;
export declare const GenerateUniqueID: () => string;
/**
 * Repair routes and folder references.
 * Remove references to non existing routes and folders.
 * Deduplicate references to the same route or folder.
 * Add references to orphan routes and folders at the root level.
 *
 * @param environment
 */
export declare const repairRefs: (environment: Environment) => Environment;
/**
 * browser randomUUID will be used when in a browser context (desktop app)
 * node randomUUID will be used when in a node context (CLI, serverless lib)
 *
 * @returns
 */
export declare const generateUUID: () => string;
/**
 * Return a random integer
 *
 * @param a
 * @param b
 */
export declare const RandomInt: (a?: number, b?: number) => number;
export declare const randomArrayItem: <T>(array: T[]) => T;
/**
 * Returns a deterministic stringified version of an object
 *
 * @param obj
 * @returns
 */
export declare const deterministicStringify: (obj: unknown) => string;
/**
 * Check that at least one item of the array is included in the provided string
 *
 * @param array
 * @param str
 * @returns
 */
export declare const stringIncludesArrayItems: (array: (string | RegExp)[], str: string) => boolean;
/**
 * Verify if the request content type is application/json
 *
 * @param headers
 */
export declare const isContentTypeApplicationJson: (headers: Header[] | string) => boolean;
/**
 * Get latency value (ms) depending on whether it should be randomized or not
 *
 * @param latency
 * @param enableRandomLatency
 */
export declare const getLatency: (latency: number, enableRandomLatency: boolean) => number;
/**
 * List routes in the order they appear in a folder children array (can be called recursively)
 *
 * If excludeList is provided, it will exclude the routes with the provided UUIDs,
 * or the routes in the provided folders by keyword in the folder name.
 * A wildcard '*' can be used to exclude all routes.
 *
 * If filterByType is provided, it will only return routes of the specified type.
 *
 * @param folderChildren - rootChildren object, or folder children array
 * @param allFolders - environment folders array
 * @param allRoutes - environment routes array
 * @param excludeList
 * @param filterByType
 * @returns
 */
export declare const routesFromFolder: (folderChildren: FolderChild[], allFolders: Folder[], allRoutes: Route[], excludeList?: string[], filterByType?: RouteType[]) => Route[];
/**
 * Creates a set of CRUD routes for a given route path
 *
 * @param routePath
 * @returns
 */
export declare const crudRoutesBuilder: (routePath: string) => readonly [{
    readonly id: "get";
    readonly docs: "Get all items";
    readonly method: "get";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "getbyId";
    readonly docs: "Get item by ID";
    readonly method: "get";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "create";
    readonly docs: "Create a new item";
    readonly method: "post";
    readonly path: string;
    readonly defaultStatus: 201;
}, {
    readonly id: "update";
    readonly docs: "Update all items";
    readonly method: "put";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "updateById";
    readonly docs: "Update item by ID";
    readonly method: "put";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "updateMerge";
    readonly docs: "Partially update all items";
    readonly method: "patch";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "updateMergeById";
    readonly docs: "Partially update item by ID";
    readonly method: "patch";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "delete";
    readonly docs: "Delete all items";
    readonly method: "delete";
    readonly path: string;
    readonly defaultStatus: 200;
}, {
    readonly id: "deleteById";
    readonly docs: "Delete item by ID";
    readonly method: "delete";
    readonly path: string;
    readonly defaultStatus: 200;
}];
