"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crudRoutesBuilder = exports.routesFromFolder = exports.getLatency = exports.isContentTypeApplicationJson = exports.stringIncludesArrayItems = exports.deterministicStringify = exports.randomArrayItem = exports.RandomInt = exports.generateUUID = exports.repairRefs = exports.GenerateUniqueID = exports.RemoveLeadingSlash = exports.IsEqual = exports.CloneObject = exports.IsValidURL = exports.GetResponseCallbackContentType = exports.GetRouteResponseContentType = exports.GetContentType = exports.dedupSlashes = void 0;
const common_constants_1 = require("../constants/common.constants");
/**
 * Deduplicate slashes in a string
 *
 * @param str
 * @returns
 */
const dedupSlashes = (str) => str.replace(/\/{2,}/g, '/');
exports.dedupSlashes = dedupSlashes;
/**
 * Extract the content-type from an array of headers
 *
 * @param headers
 */
const GetContentType = (headers) => {
    const contentTypeHeader = headers.find((header) => header.key.toLowerCase() === 'content-type');
    if (contentTypeHeader) {
        return contentTypeHeader.value;
    }
    return null;
};
exports.GetContentType = GetContentType;
/**
 * Return a route response's content-type.
 * Environment's content-type is overridden by route's content-type
 *
 * @param environment
 * @param routeResponse
 */
const GetRouteResponseContentType = (environment, routeResponse) => {
    const routeResponseContentType = (0, exports.GetContentType)(routeResponse.headers);
    const environmentContentType = (0, exports.GetContentType)(environment.headers);
    return routeResponseContentType || environmentContentType || '';
};
exports.GetRouteResponseContentType = GetRouteResponseContentType;
const GetResponseCallbackContentType = (environment, routeResponse) => {
    const routeResponseContentType = (0, exports.GetContentType)(routeResponse.headers);
    const environmentContentType = (0, exports.GetContentType)(environment.headers);
    return routeResponseContentType || environmentContentType || '';
};
exports.GetResponseCallbackContentType = GetResponseCallbackContentType;
/**
 * Test if URL is valid
 *
 * @param URL
 */
const IsValidURL = (address) => {
    try {
        new URL(address);
        return true;
    }
    catch (_error) {
        return false;
    }
};
exports.IsValidURL = IsValidURL;
/**
 * Clone an object using JSON.stringify
 * /!\ Suitable for Environment, Route, etc but not for complex objects containing Map, Set, etc
 */
const CloneObject = (objectToClone) => JSON.parse(JSON.stringify(objectToClone));
exports.CloneObject = CloneObject;
/**
 * Compare two objects using JSON.Stringify
 */
const IsEqual = (firstObject, secondObject) => JSON.stringify(firstObject) === JSON.stringify(secondObject);
exports.IsEqual = IsEqual;
const RemoveLeadingSlash = (str) => str.replace(/^\//g, '');
exports.RemoveLeadingSlash = RemoveLeadingSlash;
const GenerateUniqueID = () => (Math.random() + 1).toString(36).substring(2, 6);
exports.GenerateUniqueID = GenerateUniqueID;
/**
 * Repair routes and folder references.
 * Remove references to non existing routes and folders.
 * Deduplicate references to the same route or folder.
 * Add references to orphan routes and folders at the root level.
 *
 * @param environment
 */
const repairRefs = (environment) => {
    const routesUUIDs = environment.routes.reduce((set, route) => {
        set.add(route.uuid);
        return set;
    }, new Set());
    const foldersUUIDs = environment.folders.reduce((set, folder) => {
        set.add(folder.uuid);
        return set;
    }, new Set());
    // remove folders children that are not existing
    environment.folders.forEach((folder) => {
        folder.children = folder.children.filter((folderChild) => {
            if (folderChild.type === 'route') {
                const hasItem = routesUUIDs.has(folderChild.uuid);
                if (hasItem) {
                    routesUUIDs.delete(folderChild.uuid);
                }
                return hasItem;
            }
            else {
                const hasItem = foldersUUIDs.has(folderChild.uuid);
                if (hasItem) {
                    foldersUUIDs.delete(folderChild.uuid);
                }
                return hasItem;
            }
        });
    });
    // remove root level children the are not existing
    environment.rootChildren = environment.rootChildren.filter((rootChild) => {
        if (rootChild.type === 'route') {
            const hasItem = routesUUIDs.has(rootChild.uuid);
            if (hasItem) {
                routesUUIDs.delete(rootChild.uuid);
            }
            return hasItem;
        }
        else {
            const hasItem = foldersUUIDs.has(rootChild.uuid);
            if (hasItem) {
                foldersUUIDs.delete(rootChild.uuid);
            }
            return hasItem;
        }
    });
    // add orphan folders to the root level
    foldersUUIDs.forEach((folderUUID) => {
        environment.rootChildren.push({
            type: 'folder',
            uuid: folderUUID
        });
    });
    // add orphan routes to the root level
    routesUUIDs.forEach((routeUUID) => {
        environment.rootChildren.push({
            type: 'route',
            uuid: routeUUID
        });
    });
    return environment;
};
exports.repairRefs = repairRefs;
/**
 * browser randomUUID will be used when in a browser context (desktop app)
 * node randomUUID will be used when in a node context (CLI, serverless lib)
 *
 * @returns
 */
const generateUUID = () => typeof window !== 'undefined'
    ? window.crypto.randomUUID()
    : require('crypto').randomUUID();
exports.generateUUID = generateUUID;
/**
 * Return a random integer
 *
 * @param a
 * @param b
 */
const RandomInt = (a = 1, b = 0) => {
    const lower = Math.ceil(Math.min(a, b));
    const upper = Math.floor(Math.max(a, b));
    return Math.floor(lower + Math.random() * (upper - lower + 1));
};
exports.RandomInt = RandomInt;
const randomArrayItem = (array) => array[(0, exports.RandomInt)(0, array.length - 1)];
exports.randomArrayItem = randomArrayItem;
/**
 * Returns a deterministic stringified version of an object
 *
 * @param obj
 * @returns
 */
const deterministicStringify = (obj) => JSON.stringify(obj, (_key, value) => value instanceof Object && !(value instanceof Array)
    ? Object.keys(value)
        .sort()
        .reduce((sorted, key) => {
        sorted[key] = value[key];
        return sorted;
    }, {})
    : value);
exports.deterministicStringify = deterministicStringify;
/**
 * Check that at least one item of the array is included in the provided string
 *
 * @param array
 * @param str
 * @returns
 */
const stringIncludesArrayItems = (array, str) => array.some((item) => item instanceof RegExp ? item.test(str) : str.includes(item));
exports.stringIncludesArrayItems = stringIncludesArrayItems;
/**
 * Verify if the request content type is application/json
 *
 * @param headers
 */
const isContentTypeApplicationJson = (headers) => {
    var _a;
    const contentType = Array.isArray(headers)
        ? (_a = (0, exports.GetContentType)(headers)) === null || _a === void 0 ? void 0 : _a.toLowerCase()
        : headers.toLowerCase();
    return contentType
        ? (0, exports.stringIncludesArrayItems)(common_constants_1.ParsedJSONBodyMimeTypes, contentType)
        : false;
};
exports.isContentTypeApplicationJson = isContentTypeApplicationJson;
/**
 * Get latency value (ms) depending on whether it should be randomized or not
 *
 * @param latency
 * @param enableRandomLatency
 */
const getLatency = (latency, enableRandomLatency) => (enableRandomLatency ? (0, exports.RandomInt)(0, latency) : latency);
exports.getLatency = getLatency;
/**
 * List routes in the order they appear in a folder children array (can be called recursively)
 *
 * If excludeList is provided, it will exclude the routes with the provided UUIDs,
 * or the routes in the provided folders by keyword in the folder name.
 * A wildcard '*' can be used to exclude all routes.
 *
 * If filterByType is provided, it will only return routes of the specified type.
 *
 * @param folderChildren - rootChildren object, or folder children array
 * @param allFolders - environment folders array
 * @param allRoutes - environment routes array
 * @param excludeList
 * @param filterByType
 * @returns
 */
const routesFromFolder = (folderChildren, allFolders, allRoutes, excludeList = [], filterByType) => {
    const routesList = [];
    folderChildren.forEach((folderChild) => {
        if (folderChild.type === 'route') {
            const foundRoute = allRoutes.find((route) => route.uuid === folderChild.uuid &&
                (!filterByType || filterByType.includes(route.type)) &&
                !excludeList.includes(route.uuid) &&
                !excludeList.some((exclude) => route.endpoint.includes(exclude)) &&
                !excludeList.includes('*'));
            if (foundRoute) {
                routesList.push(foundRoute);
            }
        }
        else {
            const subFolder = allFolders.find((folder) => folder.uuid === folderChild.uuid &&
                !excludeList.some((exclude) => folder.name.includes(exclude)) &&
                !excludeList.includes('*'));
            if (subFolder) {
                routesList.push(...(0, exports.routesFromFolder)(subFolder.children, allFolders, allRoutes, excludeList));
            }
        }
    });
    return routesList;
};
exports.routesFromFolder = routesFromFolder;
/**
 * Creates a set of CRUD routes for a given route path
 *
 * @param routePath
 * @returns
 */
const crudRoutesBuilder = (routePath) => {
    const routes = [
        {
            id: 'get',
            docs: 'Get all items',
            method: 'get',
            path: (0, exports.dedupSlashes)(`${routePath}`),
            defaultStatus: 200
        },
        {
            id: 'getbyId',
            docs: 'Get item by ID',
            method: 'get',
            path: (0, exports.dedupSlashes)(`${routePath}/:id`),
            defaultStatus: 200
        },
        {
            id: 'create',
            docs: 'Create a new item',
            method: 'post',
            path: (0, exports.dedupSlashes)(`${routePath}`),
            defaultStatus: 201
        },
        {
            id: 'update',
            docs: 'Update all items',
            method: 'put',
            path: (0, exports.dedupSlashes)(`${routePath}`),
            defaultStatus: 200
        },
        {
            id: 'updateById',
            docs: 'Update item by ID',
            method: 'put',
            path: (0, exports.dedupSlashes)(`${routePath}/:id`),
            defaultStatus: 200
        },
        {
            id: 'updateMerge',
            docs: 'Partially update all items',
            method: 'patch',
            path: (0, exports.dedupSlashes)(`${routePath}`),
            defaultStatus: 200
        },
        {
            id: 'updateMergeById',
            docs: 'Partially update item by ID',
            method: 'patch',
            path: (0, exports.dedupSlashes)(`${routePath}/:id`),
            defaultStatus: 200
        },
        {
            id: 'delete',
            docs: 'Delete all items',
            method: 'delete',
            path: (0, exports.dedupSlashes)(`${routePath}`),
            defaultStatus: 200
        },
        {
            id: 'deleteById',
            docs: 'Delete item by ID',
            method: 'delete',
            path: (0, exports.dedupSlashes)(`${routePath}/:id`),
            defaultStatus: 200
        }
    ];
    return routes;
};
exports.crudRoutesBuilder = crudRoutesBuilder;
//# sourceMappingURL=utils.js.map