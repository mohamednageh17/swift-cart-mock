"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvironmentSchemaNoFix = exports.EnvironmentSchema = exports.RouteSchema = exports.DataBucketDefault = exports.HeaderDefault = exports.ResponseRuleDefault = exports.ResponseCallbackDefault = exports.CallbackDefault = exports.RouteResponseDefault = exports.RouteDefault = exports.FolderDefault = exports.EnvironmentDefault = void 0;
const tslib_1 = require("tslib");
const Joi = tslib_1.__importStar(require("joi"));
const migrations_1 = require("../libs/migrations");
const route_model_1 = require("../models/route.model");
const utils_1 = require("../utils/utils");
exports.EnvironmentDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    lastMigration: migrations_1.HighestMigrationId,
    name: 'New environment',
    endpointPrefix: '',
    latency: 0,
    port: 3000,
    hostname: '',
    folders: [],
    routes: [],
    rootChildren: [],
    proxyMode: false,
    proxyHost: '',
    proxyRemovePrefix: false,
    tlsOptions: {
        enabled: false,
        type: 'CERT',
        pfxPath: '',
        certPath: '',
        keyPath: '',
        caPath: '',
        passphrase: ''
    },
    cors: true,
    headers: [],
    proxyReqHeaders: [],
    proxyResHeaders: [],
    data: [],
    callbacks: []
};
exports.FolderDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    name: 'New folder',
    children: []
};
exports.RouteDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    type: route_model_1.RouteType.HTTP,
    documentation: '',
    method: route_model_1.Methods.get,
    endpoint: '',
    responses: [],
    responseMode: null,
    streamingMode: null,
    streamingInterval: 0
};
exports.RouteResponseDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    body: '{}',
    latency: 0,
    statusCode: 200,
    label: '',
    headers: [],
    bodyType: route_model_1.BodyTypes.INLINE,
    filePath: '',
    databucketID: '',
    sendFileAsBody: false,
    rules: [],
    rulesOperator: 'OR',
    disableTemplating: false,
    fallbackTo404: false,
    default: false,
    crudKey: 'id',
    callbacks: []
};
exports.CallbackDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    get id() {
        return (0, utils_1.GenerateUniqueID)();
    },
    uri: '',
    name: 'Callback',
    documentation: '',
    method: route_model_1.Methods.post,
    headers: [],
    bodyType: route_model_1.BodyTypes.INLINE,
    body: '',
    databucketID: '',
    filePath: '',
    sendFileAsBody: true
};
exports.ResponseCallbackDefault = {
    uuid: '',
    latency: 0
};
exports.ResponseRuleDefault = {
    target: 'body',
    modifier: '',
    value: '',
    invert: false,
    operator: 'equals'
};
exports.HeaderDefault = {
    key: '',
    value: ''
};
exports.DataBucketDefault = {
    get uuid() {
        return (0, utils_1.generateUUID)();
    },
    get id() {
        return (0, utils_1.GenerateUniqueID)();
    },
    name: 'New data',
    documentation: '',
    value: '[\n]'
};
const conditionalFailover = (fix, schema, failoverValue) => {
    if (fix) {
        return schema.failover(failoverValue);
    }
    return schema;
};
const conditionalStripUnknown = (fix) => {
    if (fix) {
        return [Joi.any().strip()];
    }
    return [];
};
const UUIDSchemaBuilder = (fix) => conditionalFailover(fix, Joi.string().uuid().required(), () => (0, utils_1.generateUUID)());
const HeaderSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    key: conditionalFailover(fix, Joi.string().allow('').required(), exports.HeaderDefault.key),
    value: conditionalFailover(fix, Joi.string().allow('').required(), exports.HeaderDefault.value)
}).options({ stripUnknown: true }), exports.HeaderDefault);
const DataSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    id: conditionalFailover(fix, Joi.string().allow('').required(), exports.DataBucketDefault.id),
    name: conditionalFailover(fix, Joi.string().allow('').required(), exports.DataBucketDefault.name),
    documentation: conditionalFailover(fix, Joi.string().allow('').required(), exports.DataBucketDefault.documentation),
    value: conditionalFailover(fix, Joi.string().allow('').required(), exports.DataBucketDefault.value)
})
    .default(exports.EnvironmentDefault.data)
    .options({ stripUnknown: true }), exports.EnvironmentDefault.data);
const TLSOptionsSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    enabled: conditionalFailover(fix, Joi.boolean().strict().required(), exports.EnvironmentDefault.tlsOptions.enabled),
    type: conditionalFailover(fix, Joi.string().valid('CERT', 'PFX').required(), exports.EnvironmentDefault.tlsOptions.type),
    pfxPath: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.tlsOptions.pfxPath),
    certPath: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.tlsOptions.certPath),
    keyPath: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.tlsOptions.keyPath),
    caPath: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.tlsOptions.caPath),
    passphrase: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.tlsOptions.passphrase)
})
    .default(exports.EnvironmentDefault.tlsOptions)
    .options({ stripUnknown: true }), exports.EnvironmentDefault.tlsOptions);
const RouteResponseRuleSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    target: conditionalFailover(fix, Joi.string()
        .valid('body', 'query', 'header', 'cookie', 'params', 'path', 'method', 'request_number', 'global_var', 'data_bucket', 'templating')
        .required(), exports.ResponseRuleDefault.target),
    modifier: conditionalFailover(fix, Joi.string().allow('').required(), exports.ResponseRuleDefault.modifier),
    value: conditionalFailover(fix, Joi.string().allow('').required(), exports.ResponseRuleDefault.value),
    invert: conditionalFailover(fix, Joi.boolean().strict().required(), exports.ResponseRuleDefault.invert),
    operator: conditionalFailover(fix, Joi.string()
        .valid('equals', 'regex', 'regex_i', 'null', 'empty_array', 'array_includes', 'valid_json_schema')
        .required(), exports.ResponseRuleDefault.operator)
}).options({
    stripUnknown: true
}), exports.ResponseRuleDefault);
const CallbackSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    id: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.id),
    name: conditionalFailover(fix, Joi.string().default('').required(), exports.CallbackDefault.name),
    documentation: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.documentation),
    method: conditionalFailover(fix, Joi.string()
        .valid(route_model_1.Methods.get, route_model_1.Methods.post, route_model_1.Methods.put, route_model_1.Methods.patch, route_model_1.Methods.delete, route_model_1.Methods.head, route_model_1.Methods.options, route_model_1.Methods.propfind, route_model_1.Methods.proppatch, route_model_1.Methods.move, route_model_1.Methods.copy, route_model_1.Methods.mkcol, route_model_1.Methods.lock, route_model_1.Methods.unlock)
        .required(), exports.CallbackDefault.method),
    uri: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.uri),
    headers: conditionalFailover(fix, Joi.array()
        .items(HeaderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.CallbackDefault.headers),
    body: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.body),
    bodyType: conditionalFailover(fix, Joi.string()
        .valid(route_model_1.BodyTypes.INLINE, route_model_1.BodyTypes.DATABUCKET, route_model_1.BodyTypes.FILE)
        .required(), exports.CallbackDefault.bodyType),
    filePath: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.filePath),
    sendFileAsBody: conditionalFailover(fix, Joi.boolean().strict().required(), exports.CallbackDefault.sendFileAsBody),
    databucketID: conditionalFailover(fix, Joi.string().allow('').required(), exports.CallbackDefault.databucketID)
})
    .default(exports.EnvironmentDefault.callbacks)
    .options({ stripUnknown: true }), exports.EnvironmentDefault.callbacks);
const CallbackInvocationSchemaBuilder = (fix) => Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    latency: Joi.number().default(0)
}).options({
    stripUnknown: true
});
const RouteResponseSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    body: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteResponseDefault.body),
    latency: conditionalFailover(fix, Joi.number().min(0).required(), exports.RouteResponseDefault.latency),
    statusCode: conditionalFailover(fix, Joi.number().min(100).max(999).required(), exports.RouteResponseDefault.statusCode),
    label: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteResponseDefault.label),
    headers: conditionalFailover(fix, Joi.array()
        .items(HeaderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.RouteResponseDefault.headers),
    bodyType: conditionalFailover(fix, Joi.string()
        .valid(route_model_1.BodyTypes.INLINE, route_model_1.BodyTypes.DATABUCKET, route_model_1.BodyTypes.FILE)
        .required(), exports.RouteResponseDefault.bodyType),
    filePath: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteResponseDefault.filePath),
    databucketID: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteResponseDefault.databucketID),
    sendFileAsBody: conditionalFailover(fix, Joi.boolean().strict().required(), exports.RouteResponseDefault.sendFileAsBody),
    rules: conditionalFailover(fix, Joi.array()
        .items(RouteResponseRuleSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.RouteResponseDefault.rules),
    rulesOperator: conditionalFailover(fix, Joi.string().valid('OR', 'AND').required(), exports.RouteResponseDefault.rulesOperator),
    disableTemplating: conditionalFailover(fix, Joi.boolean().strict().required(), exports.RouteResponseDefault.disableTemplating),
    fallbackTo404: conditionalFailover(fix, Joi.boolean().strict().required(), exports.RouteResponseDefault.fallbackTo404),
    default: conditionalFailover(fix, Joi.boolean().strict().required(), exports.RouteResponseDefault.default),
    crudKey: conditionalFailover(fix, Joi.string().required(), exports.RouteResponseDefault.crudKey),
    callbacks: conditionalFailover(fix, Joi.array()
        .items(CallbackInvocationSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.RouteResponseDefault.callbacks)
}).options({
    stripUnknown: true
}), exports.RouteResponseDefault);
const FolderChildSchemaBuilder = (fix) => Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    type: Joi.string().valid('route', 'folder').required()
});
const FolderSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    name: conditionalFailover(fix, Joi.string().allow('').required(), exports.FolderDefault.name),
    children: conditionalFailover(fix, Joi.array()
        .items(FolderChildSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.FolderDefault.children)
}).options({ stripUnknown: true }), exports.FolderDefault);
const RouteSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    type: conditionalFailover(fix, Joi.string()
        .valid(route_model_1.RouteType.HTTP, route_model_1.RouteType.CRUD, route_model_1.RouteType.WS)
        .required(), exports.RouteDefault.type),
    documentation: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteDefault.documentation),
    method: conditionalFailover(fix, Joi.string()
        .allow('')
        .valid(route_model_1.Methods.all, route_model_1.Methods.get, route_model_1.Methods.post, route_model_1.Methods.put, route_model_1.Methods.patch, route_model_1.Methods.delete, route_model_1.Methods.head, route_model_1.Methods.options, route_model_1.Methods.propfind, route_model_1.Methods.proppatch, route_model_1.Methods.move, route_model_1.Methods.copy, route_model_1.Methods.mkcol, route_model_1.Methods.lock, route_model_1.Methods.unlock)
        .required(), exports.RouteDefault.method),
    endpoint: conditionalFailover(fix, Joi.string().allow('').required(), exports.RouteDefault.endpoint),
    responses: conditionalFailover(fix, Joi.array()
        .items(RouteResponseSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.RouteDefault.responses),
    responseMode: conditionalFailover(fix, Joi.string()
        .allow(null)
        .valid(route_model_1.ResponseMode.RANDOM, route_model_1.ResponseMode.SEQUENTIAL, route_model_1.ResponseMode.DISABLE_RULES, route_model_1.ResponseMode.FALLBACK)
        .required(), exports.RouteDefault.responseMode),
    streamingMode: conditionalFailover(fix, Joi.string()
        .allow(null)
        .valid(route_model_1.StreamingMode.UNICAST, route_model_1.StreamingMode.BROADCAST)
        .required(), exports.RouteDefault.streamingMode),
    streamingInterval: conditionalFailover(fix, Joi.number().min(0).required(), exports.RouteDefault.streamingInterval)
}).options({
    stripUnknown: true
}), exports.RouteDefault);
const EnvironmentSchemaBuilder = (fix) => conditionalFailover(fix, Joi.object({
    uuid: UUIDSchemaBuilder(fix),
    lastMigration: conditionalFailover(fix, Joi.number().required(), exports.EnvironmentDefault.lastMigration),
    name: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.name),
    endpointPrefix: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.endpointPrefix),
    latency: conditionalFailover(fix, Joi.number().min(0).required(), exports.EnvironmentDefault.latency),
    port: conditionalFailover(fix, Joi.number().min(0).max(65535).required(), exports.EnvironmentDefault.port),
    hostname: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.hostname),
    rootChildren: conditionalFailover(fix, Joi.array()
        .items(FolderChildSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.rootChildren),
    folders: conditionalFailover(fix, Joi.array()
        .items(FolderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.folders),
    routes: conditionalFailover(fix, Joi.array()
        .items(RouteSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.routes),
    proxyMode: conditionalFailover(fix, Joi.boolean().strict().required(), exports.EnvironmentDefault.proxyMode),
    proxyHost: conditionalFailover(fix, Joi.string().allow('').required(), exports.EnvironmentDefault.proxyHost),
    proxyRemovePrefix: conditionalFailover(fix, Joi.boolean().strict().required(), exports.EnvironmentDefault.proxyRemovePrefix),
    tlsOptions: TLSOptionsSchemaBuilder(fix),
    cors: conditionalFailover(fix, Joi.boolean().strict().required(), exports.EnvironmentDefault.cors),
    headers: conditionalFailover(fix, Joi.array()
        .items(HeaderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.headers),
    proxyReqHeaders: conditionalFailover(fix, Joi.array()
        .items(HeaderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.proxyReqHeaders),
    proxyResHeaders: conditionalFailover(fix, Joi.array()
        .items(HeaderSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.proxyResHeaders),
    data: conditionalFailover(fix, Joi.array()
        .items(DataSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.data),
    callbacks: conditionalFailover(fix, Joi.array()
        .items(CallbackSchemaBuilder(fix), ...conditionalStripUnknown(fix))
        .required(), exports.EnvironmentDefault.callbacks)
})
    .default(exports.EnvironmentDefault)
    .options({
    stripUnknown: true
}), exports.EnvironmentDefault);
exports.RouteSchema = RouteSchemaBuilder(true);
exports.EnvironmentSchema = EnvironmentSchemaBuilder(true);
exports.EnvironmentSchemaNoFix = EnvironmentSchemaBuilder(false);
//# sourceMappingURL=environment-schema.constants.js.map