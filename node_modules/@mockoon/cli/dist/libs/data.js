"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDataFile = exports.loadFile = void 0;
const commons_1 = require("@mockoon/commons");
const fs_1 = require("fs");
const config_1 = require("../config");
const cli_messages_constants_1 = require("../constants/cli-messages.constants");
const utils_1 = require("./utils");
/**
 * Check if an environment can be run by the CLI and
 * migrate it if needed.
 * Validate the environment schema (will automatically repair)
 *
 * @param environment
 */
const migrateAndValidateEnvironment = async (environment, forceRepair) => {
    // environment data are too old: lastMigration is not present
    if (environment.lastMigration === undefined && !forceRepair) {
        const answer = await (0, utils_1.confirm)(`${environment.name ? '"' + environment.name + '"' : 'This environment'} does not seem to be a valid Mockoon environment or is too old. Let Mockoon attempt to repair it?`);
        if (!answer) {
            throw new Error(cli_messages_constants_1.CLIMessages.DATA_TOO_OLD_ERROR);
        }
    }
    // environment data migrated with a more recent version (if installed CLI version does not include @mockoon/commons with required migrations)
    if (environment.lastMigration > commons_1.HighestMigrationId) {
        throw new Error(cli_messages_constants_1.CLIMessages.DATA_TOO_RECENT_ERROR);
    }
    try {
        // apply migrations
        commons_1.Migrations.forEach((migration) => {
            if (migration.id > environment.lastMigration) {
                migration.migrationFunction(environment);
            }
        });
    }
    catch (_error) {
        environment.lastMigration = commons_1.HighestMigrationId;
    }
    let validatedEnvironment = commons_1.EnvironmentSchema.validate(environment).value;
    if (!validatedEnvironment) {
        throw new Error(cli_messages_constants_1.CLIMessages.DATA_INVALID);
    }
    validatedEnvironment = (0, commons_1.repairRefs)(validatedEnvironment);
    return validatedEnvironment;
};
/**
 * Load a file from the filesystem or a URL. If a cloud URL is provided,
 * it will fetch the environment from the API.
 * If parse is true, it will also parse the file content as JSON.
 *
 * @param filePath - path or URL to the file
 * @param parse - set to false to return raw file content
 * @param token - optional token for authenticating cloud requests
 * @returns
 */
const loadFile = async (filePath, parse, token) => {
    try {
        let data;
        if (filePath.startsWith('http')) {
            data = await (await fetch(filePath)).text();
        }
        else if (filePath.startsWith(config_1.Config.cloudScheme)) {
            const environmentId = filePath.replace(config_1.Config.cloudScheme, '');
            const response = await fetch(`${config_1.Config.cloudApiUrl}/${environmentId}`, {
                headers: {
                    Authorization: `Bearer ${token}`
                }
            });
            if (!response.ok) {
                let message;
                if (response.status === 401 || response.status === 403) {
                    message = `Failed to load cloud environment ${environmentId}: unauthorized access (invalid or expired token, or insufficient permissions).`;
                }
                else if (response.status === 404) {
                    message = `Failed to load cloud environment ${environmentId}: environment not found or you do not have access to it.`;
                }
                else {
                    message = `Failed to load cloud environment ${environmentId}: ${response.status} ${response.statusText}`;
                }
                throw new Error(message);
            }
            data = await response.text();
        }
        else {
            data = await fs_1.promises.readFile(filePath, { encoding: 'utf-8' });
        }
        if (parse && typeof data === 'string') {
            data = JSON.parse(data);
        }
        return data;
    }
    catch (error) {
        throw new Error(`could not load file ${filePath}: ${error.message}`);
    }
};
exports.loadFile = loadFile;
/**
 * Load and parse a JSON data file.
 *
 * @param filePaths
 */
const parseDataFile = async (filePath, userOptions = { port: undefined, hostname: undefined }, repair = false, token) => {
    const openAPIConverter = new commons_1.OpenApiConverter();
    const data = await (0, exports.loadFile)(filePath, false, token);
    let errorMessage = `${cli_messages_constants_1.CLIMessages.DATA_INVALID}:`;
    let environment = null;
    try {
        environment = await openAPIConverter.convertFromOpenAPI(data);
    }
    catch (openAPIError) {
        if (openAPIError instanceof Error) {
            errorMessage += `\nOpenAPI parser: ${openAPIError.message}`;
        }
        // immediately throw if the file is not a JSON file (mockoon only supports JSON files)
        if (filePath.includes('.yml') || filePath.includes('.yaml')) {
            throw new Error(errorMessage);
        }
        try {
            if (typeof data === 'string') {
                environment = JSON.parse(data);
            }
            if (environment) {
                environment = await migrateAndValidateEnvironment(environment, repair);
            }
        }
        catch (JSONError) {
            if (JSONError instanceof Error) {
                errorMessage += `\nMockoon parser: ${JSONError.message}`;
            }
            throw new Error(errorMessage);
        }
    }
    if (environment) {
        if (userOptions.port !== undefined) {
            environment.port = userOptions.port;
        }
        if (userOptions.hostname !== undefined) {
            environment.hostname = userOptions.hostname;
        }
        if (userOptions.proxy) {
            environment.proxyMode = userOptions.proxy === 'enabled';
        }
    }
    if (!environment) {
        throw new Error(cli_messages_constants_1.CLIMessages.ENVIRONMENT_NOT_AVAILABLE_ERROR);
    }
    return { originalPath: filePath, environment };
};
exports.parseDataFile = parseDataFile;
//# sourceMappingURL=data.js.map