import { match } from 'path-to-regexp';
import { CloneObject } from '@mockoon/commons';
import { parse as parseUrl } from 'url';
import { parseRequestMessage, parseWebSocketMessage } from './utils';
const toString = (data) => {
    if (typeof data === 'string') {
        return data;
    }
    else if (typeof data === 'object') {
        return JSON.stringify(data);
    }
    else if (typeof data === 'undefined') {
        return undefined;
    }
    return data + '';
};
const parseCookies = (req) => {
    var _a;
    const obj = {};
    const cookieHeader = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.cookie;
    if (!cookieHeader) {
        return obj;
    }
    cookieHeader.split(';').forEach((cookie) => {
        const [name, ...rest] = cookie.split('=');
        if (!name) {
            return;
        }
        const value = rest.join('=').trim();
        if (!value) {
            // skip pairs with empty values
            return;
        }
        obj[name.trim()] = decodeURIComponent(value);
    });
    return obj;
};
/**
 * Creates a common ServerRequest instance from Express request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req Express request object
 * @returns Mockoon common server request
 */
export const fromExpressRequest = (req) => {
    var _a, _b;
    return ({
        body: req.body,
        cookies: req.cookies,
        header: (name) => { var _a; return (_a = req.header) === null || _a === void 0 ? void 0 : _a.call(req, name); },
        headers: req.headers,
        get: (headerName) => { var _a; return (_a = req.header) === null || _a === void 0 ? void 0 : _a.call(req, headerName); },
        hostname: req.hostname,
        ip: req.ip,
        method: req.method,
        params: req.params,
        // store the original path of the request, e.g. /api/v1/users/:id
        originalPath: (_b = (_a = req.route) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '',
        originalRequest: req,
        query: req.query,
        stringBody: req.stringBody || ''
    });
};
/**
 * Creates a common ServerRequest instance from Web socket request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req websocket connection request
 * @param message message received from websocket now
 */
export const fromWsRequest = (req, originalRoute, message) => {
    var _a, _b, _c;
    const location = parseUrl(req.url || '', true);
    let pathParams = {};
    const urlPathMatchFn = match(originalRoute.endpoint.startsWith('/')
        ? originalRoute.endpoint
        : '/' + originalRoute.endpoint);
    const result = urlPathMatchFn(location.pathname || '');
    if (result) {
        pathParams = result.params || {};
    }
    const structuredMessage = message
        ? parseWebSocketMessage(message || '', req)
        : undefined;
    return {
        body: structuredMessage || req.body,
        cookies: parseCookies(req),
        headers: req.headers,
        header: (name) => { var _a; return (_a = req.headers) === null || _a === void 0 ? void 0 : _a[name]; },
        get: (headerName) => { var _a; return (_a = req.headers) === null || _a === void 0 ? void 0 : _a[headerName]; },
        hostname: (_a = req.headers) === null || _a === void 0 ? void 0 : _a['host'],
        ip: ((_b = req.headers) === null || _b === void 0 ? void 0 : _b['x-forwarded-for']) || ((_c = req.socket) === null || _c === void 0 ? void 0 : _c.remoteAddress),
        method: req.method,
        originalPath: `${originalRoute.endpoint.startsWith('/') ? '' : '/'}${originalRoute.endpoint}`,
        originalRequest: req,
        params: CloneObject(pathParams),
        query: CloneObject(location.query),
        stringBody: message || toString(req.body) || ''
    };
};
/**
 * Copies the given request with a new message.
 *
 * This method is useful to mimic the behaviour of websockets, because,
 * we need to keep the access of original connection request and then subsequent messages
 * in a full-duplex communication. This will update the body content with the received
 * message, so that helper classes will use that instead of original body.
 *
 * @param req
 * @param message received web socket message.
 * @returns
 */
export const fromServerRequest = (req, message) => {
    const structuredMessage = message
        ? parseRequestMessage(message || '', req)
        : undefined;
    return {
        body: structuredMessage || req.body,
        cookies: req.cookies,
        headers: req.headers,
        header: req.header,
        get: req.get,
        hostname: req.hostname,
        ip: req.ip,
        method: req.method,
        originalPath: req.originalPath,
        originalRequest: req.originalRequest,
        params: req.params,
        query: req.query,
        stringBody: message || req.stringBody || ''
    };
};
//# sourceMappingURL=requests.js.map