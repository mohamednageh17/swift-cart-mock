import { ServerErrorCodes } from '@mockoon/commons';
import { readFile } from 'fs';
import { WebSocket } from 'ws';
import { ResponseRulesInterpreter } from '../response-rules-interpreter';
export const SMALLEST_POSSIBLE_STREAMING_INTERVAL = 10;
/**
 * Returns a safe streaming interval for one-to-one and broadcast websockets.
 * Having a small interval could make server potentially unusable.
 */
export const getSafeStreamingInterval = (givenInterval) => Math.max(SMALLEST_POSSIBLE_STREAMING_INTERVAL, givenInterval);
/**
 * Represents a single running streaming data for a route.
 * For all socket clients, there will be only one single instance.
 */
export class WsRunningInstance {
    constructor(route, serverContext, serverRequest, handler) {
        this.route = route;
        this.serverContext = serverContext;
        this.serverRequest = serverRequest;
        this.handler = handler;
        this.isRunning = false;
    }
    get running() {
        return this.isRunning;
    }
    run() {
        let responseNumber = 1;
        this.closeable = setInterval(() => {
            const enabledRouteResponse = new ResponseRulesInterpreter(this.route.responses, this.serverRequest, this.route.responseMode, this.serverContext.environment, this.serverContext.processedDatabuckets, this.serverContext.globalVariables, this.serverContext.envVarPrefix, this.serverContext.publicBaseUrl).chooseResponse(responseNumber);
            if (!enabledRouteResponse) {
                return;
            }
            responseNumber += 1;
            this.handler(responseNumber, enabledRouteResponse);
        }, getSafeStreamingInterval(this.route.streamingInterval));
        this.isRunning = true;
    }
    close() {
        if (this.closeable) {
            clearInterval(this.closeable);
            this.isRunning = false;
        }
    }
}
/**
 * Context for all websocket broadcast end points.
 * This class holds all streaming data generators per route.
 * This guarantees that it creates one and only generator for a given route.
 */
export class BroadcastContext {
    constructor() {
        this.routeDataGenerators = new Map();
    }
    get runningInstances() {
        return new Set(this.routeDataGenerators.keys());
    }
    static getInstance() {
        if (!BroadcastContext.context) {
            BroadcastContext.context = new BroadcastContext();
        }
        return BroadcastContext.context;
    }
    registerRoute(route, serverContext, serverRequest, nextResponseHandler) {
        const ref = this.routeDataGenerators.get(route.endpoint);
        if (ref) {
            // A reference already exists. So, broadcasting will be done by it.
            // No need to create another.
            return false;
        }
        const instance = new WsRunningInstance(route, serverContext, serverRequest, nextResponseHandler);
        this.routeDataGenerators.set(route.endpoint, instance);
        instance.run();
        return true;
    }
    /**
     * This will close all running contexts.
     */
    closeAll() {
        this.routeDataGenerators.forEach((runner) => {
            runner.close();
        });
        this.routeDataGenerators.clear();
    }
    closeRoute(route) {
        const ref = this.routeDataGenerators.get(route.endpoint);
        if (ref) {
            this.routeDataGenerators.delete(route.endpoint);
            ref.close();
        }
    }
}
/**
 * Convert incoming websocket message to string representation.
 *
 * @param message
 */
export const messageToString = (message) => {
    if (!message) {
        return '';
    }
    if (Array.isArray(message)) {
        return Buffer.concat(message).toString('utf8');
    }
    return message.toString('utf8');
};
/**
 * Returns true if the given socket client is still in open state.
 *
 * @param socket
 */
export const isWebSocketOpen = (socket) => socket.readyState === WebSocket.OPEN;
/**
 * Serve the content of the file as a response.
 * Will use templating if specified to do so.
 *
 * @param socket
 * @param route
 * @param routeResponse
 * @param eventEmitter
 * @param filePath
 * @param templateParser
 */
export const serveFileContentInWs = (socket, route, routeResponse, eventEmitter, filePath, templateParser) => {
    readFile(filePath, (err, fileData) => {
        if (err) {
            eventEmitter.emit('error', ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, err, {
                routePath: route.endpoint,
                routeUUID: route.uuid
            });
            // we close the socket if the provided file cannot be read.
            socket.send(`Status: 500, File reading error! (${err.message})`, () => {
                socket.close();
            });
        }
        else {
            let fileContent = fileData.toString();
            if (!routeResponse.disableTemplating) {
                fileContent = templateParser(fileContent);
            }
            socket.send(fileContent);
        }
    });
};
//# sourceMappingURL=ws.js.map