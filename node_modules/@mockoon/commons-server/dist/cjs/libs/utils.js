"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidStatusCode = exports.parseRequestMessage = exports.parseWebSocketMessage = exports.getValueFromPath = exports.isSafeJSONPath = exports.fullTextSearch = exports.escapeRegExp = exports.preparePath = exports.convertPathToArray = exports.resolvePathFromEnvironment = exports.objectFromSafeString = exports.numberFromSafeString = exports.fromSafeString = exports.FromBase64 = exports.ToBase64 = exports.DecompressBody = exports.IsEmpty = exports.objectGetPath = exports.mimeTypeLookup = void 0;
exports.isBodySupportingMethod = isBodySupportingMethod;
exports.CreateCallbackInvocation = CreateCallbackInvocation;
exports.CreateInFlightRequest = CreateInFlightRequest;
exports.CreateTransaction = CreateTransaction;
const jmespath_1 = require("@jmespath-community/jmespath");
const commons_1 = require("@mockoon/commons");
const handlebars_1 = require("handlebars");
const jsonpath_plus_1 = require("jsonpath-plus");
const object_path_1 = require("object-path");
const path_1 = require("path");
const url_1 = require("url");
const xml_js_1 = require("xml-js");
const zlib_1 = require("zlib");
var mime_types_1 = require("mime-types");
Object.defineProperty(exports, "mimeTypeLookup", { enumerable: true, get: function () { return mime_types_1.lookup; } });
var object_path_2 = require("object-path");
Object.defineProperty(exports, "objectGetPath", { enumerable: true, get: function () { return object_path_2.get; } });
/**
 * Transform http headers objects to Mockoon's Header key value object
 *
 * @param object
 */
const TransformHeaders = (headers) => Object.keys(headers).reduce((newHeaders, key) => {
    const headerValue = headers[key];
    let value = '';
    if (headerValue !== undefined) {
        if (Array.isArray(headerValue)) {
            value = headerValue.join(',');
        }
        else {
            value = headerValue.toString();
        }
    }
    newHeaders.push({ key, value });
    return newHeaders;
}, []);
/**
 * Sort by ascending order
 *
 * @param a
 * @param b
 */
const AscSort = (a, b) => {
    if (a.key < b.key) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
const IsEmpty = (obj) => (Array.isArray(obj) || (obj instanceof Object && obj !== null)) &&
    !Object.entries(obj || {}).length;
exports.IsEmpty = IsEmpty;
/**
 * Decompress body based on content-encoding
 *
 * Zstd support requires Node.js 22 or higher, thus it is conditionally applied
 *
 * @param response
 */
const DecompressBody = (response) => {
    if (!response.body) {
        return response.body;
    }
    const contentEncoding = response.getHeader('content-encoding');
    let body = response.body;
    switch (contentEncoding) {
        case 'gzip':
            body = (0, zlib_1.unzipSync)(body);
            break;
        case 'br':
            body = (0, zlib_1.brotliDecompressSync)(body);
            break;
        case 'deflate':
            body = (0, zlib_1.inflateSync)(body);
            break;
        case 'zstd':
            {
                // eslint-disable-next-line
                const zlib = require('zlib');
                if (zlib.zstdDecompressSync) {
                    body = zlib.zstdDecompressSync(body);
                }
            }
            break;
        default:
            break;
    }
    return body.toString('utf-8');
};
exports.DecompressBody = DecompressBody;
/**
 * Returns true if given HTTP method is a body supporting one. Otherwise false.
 * @param method
 */
function isBodySupportingMethod(method) {
    return [commons_1.Methods.put, commons_1.Methods.post, commons_1.Methods.patch].includes(method);
}
/**
 * Creates a callback invocation record which has information
 * about the invoked details.
 * @param callback
 * @param url
 * @param requestBody
 * @param requestHeaders
 * @param fetchResponse
 * @param responseBody
 */
function CreateCallbackInvocation(callback, url, requestBody, requestHeaders, fetchResponse, responseBody) {
    const resHeadersObj = Object.fromEntries(fetchResponse.headers.entries());
    return {
        name: callback.name,
        url,
        method: callback.method,
        requestBody,
        requestHeaders,
        status: fetchResponse.status,
        responseBody,
        responseHeaders: Object.keys(resHeadersObj).map((k) => ({ key: k, value: resHeadersObj[k] }))
    };
}
/**
 * Creates in-flight request object.
 *
 * @param requestId
 * @param request
 * @param route
 */
function CreateInFlightRequest(requestId, request, route) {
    const parsedUrl = (0, url_1.parse)(request.url || '', true);
    return {
        requestId,
        routeUUID: route.uuid,
        request: {
            method: request.method || 'get',
            urlPath: parsedUrl.pathname,
            route: route.endpoint,
            headers: TransformHeaders(request.headers).sort(AscSort),
            body: request.body,
            query: parsedUrl.search,
            params: [], // we don't support params yet
            queryParams: parsedUrl.query
                ? Object.keys(parsedUrl.query).map((k) => ({
                    name: k,
                    value: parsedUrl.query[k]
                }))
                : []
        },
        completed: false
    };
}
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
function CreateTransaction(request, response) {
    const requestUrl = new url_1.URL(request.originalUrl, 'http://localhost/');
    let queryString = requestUrl.search.slice(1);
    try {
        queryString = decodeURI(queryString);
    }
    catch (_error) { }
    return {
        request: {
            method: request.method.toLowerCase(),
            urlPath: requestUrl.pathname,
            route: request.route ? request.route.path : null,
            params: request.params
                ? Object.keys(request.params).map((paramName) => ({
                    name: paramName,
                    value: request.params[paramName]
                }))
                : [],
            query: requestUrl ? queryString : null,
            queryParams: request.query,
            body: request.stringBody,
            headers: TransformHeaders(request.headers).sort(AscSort)
        },
        response: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: TransformHeaders(response.getHeaders()).sort(AscSort),
            body: (0, exports.DecompressBody)(response)
        },
        routeResponseUUID: response.routeResponseUUID,
        routeUUID: response.routeUUID,
        proxied: request.proxied || false,
        timestampMs: Date.now()
    };
}
/**
 * Convert a string to base64
 *
 * @param text
 */
const ToBase64 = (text) => Buffer.from(text, 'utf-8').toString('base64');
exports.ToBase64 = ToBase64;
/**
 * Convert base64 to a string
 *
 * @param base64
 */
const FromBase64 = (base64) => Buffer.from(base64, 'base64').toString('utf-8');
exports.FromBase64 = FromBase64;
/**
 * Extract the string value from a SafeString
 *
 * @param value
 * @returns
 */
const fromSafeString = (value) => value instanceof handlebars_1.SafeString ? value.toString() : value;
exports.fromSafeString = fromSafeString;
/**
 * Parse a number from a SafeString if needed.
 *
 * @param text
 * @returns
 */
const numberFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    return parseInt(parsedText, 10);
};
exports.numberFromSafeString = numberFromSafeString;
/**
 *
 * @param text
 * @returns object | null
 */
const objectFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    // Remove any escape slashes used to escape double-quotes or single-quotes
    // (Check test case).
    // Surround all object keys with double-quotes to make it valid JSON text.
    const objectText = parsedText
        .replace(/\\/g, '')
        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": ');
    try {
        return JSON.parse(objectText);
    }
    catch (_error) {
        return null;
    }
};
exports.objectFromSafeString = objectFromSafeString;
/**
 * Resolve a file path relatively to the current environment folder if provided
 */
const resolvePathFromEnvironment = (filePath, environmentDirectory) => {
    if (environmentDirectory && !(0, path_1.isAbsolute)(filePath)) {
        return (0, path_1.resolve)(environmentDirectory, filePath);
    }
    return filePath;
};
exports.resolvePathFromEnvironment = resolvePathFromEnvironment;
/**
 * Convert an object path (for the object-path lib) containing escaped dots '\.'
 * to an array of strings to allow fetching properties containing dots.
 *
 * Example:
 * 'get.a.property\.with\.dots => ['get', 'a', 'property.with.dots']
 *
 * To query an object like this:
 *
 * ```
 * {
 *   get: {
 *     a: {
 *       'property.with.dots': "value"
 *     }
 *   }
 * }
 * ```
 * @param str
 */
const convertPathToArray = (str) => {
    if (str.includes('\\.')) {
        return str
            .replace(/\\\./g, '%#%')
            .split('.')
            .map((s) => s.replace(/%#%/g, '.'));
    }
    return str;
};
exports.convertPathToArray = convertPathToArray;
/**
 * Prepare a path for express: add a leading slash, deduplicate slashes and replace spaces with %20
 *
 * @param endpointPrefix
 * @param endpoint
 * @returns
 */
const preparePath = (endpointPrefix, endpoint) => (0, commons_1.dedupSlashes)(`/${endpointPrefix}/${endpoint.replace(/ /g, '%20')}`);
exports.preparePath = preparePath;
/**
 * Escape special characters in a string to be used in a regex
 * Taken from Lodash escapeRegExp
 *
 * @param text
 * @returns
 */
const escapeRegExp = (text) => {
    return text.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
};
exports.escapeRegExp = escapeRegExp;
/**
 * Perform a full text search on an object. The object can be any valid JSON type
 *
 * @param object
 * @param query
 * @returns
 */
const fullTextSearch = (object, query) => {
    if (typeof object === 'object' || typeof object === 'boolean') {
        return Object.values(object !== null && object !== void 0 ? object : []).some((value) => (0, exports.fullTextSearch)(value, query));
    }
    return new RegExp((0, exports.escapeRegExp)(query), 'i').test(String(object));
};
exports.fullTextSearch = fullTextSearch;
/**
 * Validates a given JSONPath string to check if the filter expressions are safe for evaluation.
 * If no filter expression is found in the path, it returns the path as valid.
 * If filter expressions are found, each one is checked against a regular expression to ensure it is safe.
 * The function returns a boolean indicating whether the path is valid.
 *
 * If path is too long, it is considered unsafe due to the time complexity of the hasFilter check.
 *
 * @param {string} path - The JSONPath string to be validated.
 * @returns {boolean} - whether JSONPath string is safe or not
 */
const isSafeJSONPath = (path) => {
    var _a;
    /* filterRE is used to match each individual filter expression */
    const FILTER_RE = new RegExp('^' +
        // eventually wrapped in parentheses: e.g. (@property === 'price')
        '[(]*' +
        // Group 1: Allow l.h.s names like - @price or @.group or @['Account Name'] or length-1 or @.match(/regex/)
        // Keys with spaces are allowed
        "(@{0,1}\\.{0,1}[_a-zA-Z0-9\\-\\[\\]\\.]*|@{0,1}\\['[_a-zA-Z0-9\\s]*'\\]|@[a-zA-Z0-9_\\s'\\-\\[\\]\\.]*.match\\(.*\\))" +
        '\\s*' + // ignore any whitespaces before the operator
        // Group 2 (optional): Supported operators ==, !=, ===, !==, <, >, <=, >=
        '(==|!=|===|!==|<|<=|>|>=)?' +
        '\\s*' + // ignore any whitespaces after the operator
        // Group 3 (optional): Supported r.h.s - single/double quoted strings, numbers, boolean, undefined,
        // reference to other properties like @. or $.
        // Keys with spaces are allowed
        "(\"[^\"]*\"|'[^']*'|[0-9.]+|@{0,1}\\${0,1}[\\.a-zA-Z0-9_\\[\\]\\s']*|true|false|undefined)?" +
        // eventually wrapped in parentheses: e.g. (@property === 'price')
        '[)]*' +
        '$');
    /*
     * groupRE is used to capture each individual filter in case && or || are being used
     * Returns individual filter expression groups (value without ())
     */
    const GROUP_RE = new RegExp('\\s*&&\\s*|\\s*\\|\\|\\s*', // Non capturing group matching ' && ' or ' || ' or EOL
    'g');
    if (path.length > 1000) {
        return false;
    }
    const hasFilter = ((_a = /\((.*)\)/.exec(path)) !== null && _a !== void 0 ? _a : [])[1];
    if (!hasFilter) {
        return true;
    }
    const filters = hasFilter.split(GROUP_RE);
    if (!filters) {
        return true;
    }
    let isValid = true;
    // Recursively test each filter expression
    for (let filter of filters) {
        filter = filter.trim();
        if (!FILTER_RE.test(filter)) {
            isValid = false;
        }
    }
    return isValid;
};
exports.isSafeJSONPath = isSafeJSONPath;
/**
 * Look for a value in an object or array using a path (dot notation or JSONPath).
 * If no path is provided, return the full data.
 * If the value is not found, return the default value.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
const getValueFromPath = (data, path, defaultValue) => {
    if ((Array.isArray(data) || typeof data === 'object') &&
        typeof path === 'string' &&
        path !== '') {
        let foundValue;
        // Added wrap = false (Check https://github.com/mockoon/mockoon/issues/1297)
        if (path.startsWith('$')) {
            if ((0, exports.isSafeJSONPath)(path)) {
                foundValue = (0, jsonpath_plus_1.JSONPath)({ json: data, path: path, wrap: false });
            }
        }
        else {
            foundValue = (0, object_path_1.get)(data, (0, exports.convertPathToArray)(path));
        }
        return foundValue !== undefined ? foundValue : defaultValue;
    }
    return data;
};
exports.getValueFromPath = getValueFromPath;
/**
 * Look for a value in an object or array using JMESPath.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
exports.getValueFromPath.jmesPath = (data, path, defaultValue) => {
    if ((Array.isArray(data) || typeof data === 'object') &&
        typeof path === 'string' &&
        path !== '') {
        let foundValue;
        try {
            foundValue = (0, jmespath_1.search)(data, path);
        }
        catch (_error) {
            // silently fail if the path is invalid (same as JSONPath)
        }
        // JMESPath returns null if the value is not found (unlike JSONPath which returns undefined)
        return foundValue !== null && foundValue !== void 0 ? foundValue : defaultValue;
    }
    return data;
};
/**
 * Look for a value in an object or array using JSONPath.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
exports.getValueFromPath.jsonPath = (data, path, defaultValue) => {
    if ((Array.isArray(data) || typeof data === 'object') &&
        typeof path === 'string' &&
        path !== '') {
        let foundValue;
        if ((0, exports.isSafeJSONPath)(path)) {
            // Added wrap = false (Check https://github.com/mockoon/mockoon/issues/1297)
            foundValue = (0, jsonpath_plus_1.JSONPath)({ json: data, path: path, wrap: false });
        }
        return foundValue !== undefined ? foundValue : defaultValue;
    }
    return data;
};
/**
 * Get a value from an object or array using object-path.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
exports.getValueFromPath.objectPath = (data, path, defaultValue) => {
    if ((Array.isArray(data) || typeof data === 'object') &&
        typeof path === 'string' &&
        path !== '') {
        const foundValue = (0, object_path_1.get)(data, (0, exports.convertPathToArray)(path));
        return foundValue !== undefined ? foundValue : defaultValue;
    }
    return data;
};
/**
 * Returns data based on the content type.
 *
 * @param data
 * @param contentType
 */
const parseByContentType = (data, contentType) => {
    if (contentType) {
        if ((0, commons_1.stringIncludesArrayItems)(commons_1.ParsedJSONBodyMimeTypes, contentType)) {
            return JSON.parse(data || '{}');
        }
        else if ((0, commons_1.stringIncludesArrayItems)(commons_1.ParsedXMLBodyMimeTypes, contentType)) {
            return (0, xml_js_1.xml2js)(data, { compact: true });
        }
    }
    return data;
};
/**
 * Parses a websocket message based on the content-type specified in the socket connection.
 * We have to use this function, because this has to be called when creating a Mockoon
 * ServerRequest object from a WS connection request.
 *
 * @param messageData
 * @param request
 */
const parseWebSocketMessage = (messageData, request) => {
    const contentType = request === null || request === void 0 ? void 0 : request.headers['content-type'];
    return parseByContentType(messageData, contentType);
};
exports.parseWebSocketMessage = parseWebSocketMessage;
/**
 * Returns appropriate object by parsing it as necessary.
 * This will check content-type header and will parse messageData based on the type.
 *
 * @param data
 * @param request
 */
const parseRequestMessage = (data, request) => {
    const contentType = request === null || request === void 0 ? void 0 : request.header('content-type');
    return parseByContentType(data, contentType);
};
exports.parseRequestMessage = parseRequestMessage;
/**
 * Validate status code (100-999)
 *
 * @param statusCode - The status code to validate
 * @returns boolean
 */
const isValidStatusCode = (statusCode) => {
    return Number.isInteger(statusCode) && statusCode >= 100 && statusCode <= 999;
};
exports.isValidStatusCode = isValidStatusCode;
//# sourceMappingURL=utils.js.map