"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockoonServer = void 0;
const tslib_1 = require("tslib");
const commons_1 = require("@mockoon/commons");
const append_field_1 = tslib_1.__importDefault(require("append-field"));
const busboy_1 = tslib_1.__importDefault(require("busboy"));
const cookie_parser_1 = tslib_1.__importDefault(require("cookie-parser"));
const events_1 = require("events");
const express_1 = tslib_1.__importDefault(require("express"));
const fs_1 = require("fs");
const http_1 = require("http");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const https_1 = require("https");
const killable_1 = tslib_1.__importDefault(require("killable"));
const node_net_1 = require("node:net");
const path_1 = require("path");
const path_to_regexp_1 = require("path-to-regexp");
const qs_1 = require("qs");
const range_parser_1 = tslib_1.__importDefault(require("range-parser"));
const url_1 = require("url");
const util_1 = require("util");
const ws_1 = require("ws");
const xml_js_1 = require("xml-js");
const server_messages_constants_1 = require("../../constants/server-messages.constants");
const ssl_constants_1 = require("../../constants/ssl.constants");
const faker_1 = require("../faker");
const requests_1 = require("../requests");
const response_rules_interpreter_1 = require("../response-rules-interpreter");
const template_parser_1 = require("../template-parser");
const request_helpers_1 = require("../templating-helpers/request-helpers");
const utils_1 = require("../utils");
const admin_api_1 = require("./admin-api");
const crud_1 = require("./crud");
const ws_2 = require("./ws");
/**
 * Create a server instance from an Environment object.
 *
 * Extends an EventEmitter.
 *
 * ⚠️ The function listenServerEvents must be used to listen to server events
 * and avoid the EventEmitter to throw errors due to the lack of listeners.
 *
 * Example:
 *
 * ```
 * const server = new MockoonServer(environment);
 * const logger = createLoggerInstance();
 * listenServerEvents(server, environment, logger, false);
 *
 * // or ate least listen to the error event
 * server.on('error', (errorCode, originalError) => {});
 * ```
 */
class MockoonServer extends events_1.EventEmitter {
    constructor(environment, options = {}) {
        var _a;
        super();
        this.environment = environment;
        this.webSocketServers = [];
        this.tlsOptions = {};
        this.processedDatabuckets = [];
        // store the request number for each route
        this.requestNumbers = {};
        // templating global variables
        this.globalVariables = {};
        this.options = {
            environmentDirectory: '.',
            disabledRoutes: [],
            envVarsPrefix: commons_1.defaultEnvironmentVariablesPrefix,
            enableAdminApi: true,
            disableTls: false,
            maxTransactionLogs: commons_1.defaultMaxTransactionLogs,
            enableRandomLatency: false,
            maxFileUploads: 10,
            maxFileSize: 10 * 1024 * 1024 // 10MB
        };
        this.transactionLogs = [];
        /**
         * ### Middleware ###
         * Remove the Expect: 100-continue header.
         * Express will always respond with 100 Continue if the header is present.
         *
         * However, http-proxy-middleware hang (onProxyReq is not triggered) if the header is present.
         * See https://github.com/http-party/node-http-proxy/issues/1219
         * A workaround would be to remove it and re-add it in the onProxyReq function,
         * but it's probably better to just remove it.
         *
         * @param request
         * @param response
         * @param next
         */
        this.removeExpectHeader = (request, response, next) => {
            const expectHeader = request.get('expect');
            if (expectHeader === null || expectHeader === void 0 ? void 0 : expectHeader.toLowerCase().includes('100-continue')) {
                delete request.headers.expect;
            }
            next();
        };
        /**
         * ### Middleware ###
         * Emit the SERVER_ENTERING_REQUEST event
         *
         * @param request
         * @param response
         * @param next
         */
        this.emitEvent = (request, response, next) => {
            this.emit('entering-request');
            next();
        };
        /**
         * ### Middleware ###
         * Add global latency to the mock server
         *
         * @param request
         * @param response
         * @param next
         */
        this.delayResponse = (request, response, next) => {
            setTimeout(next, (0, commons_1.getLatency)(this.environment.latency, this.options.enableRandomLatency));
        };
        /**
         * ### Middleware ###
         * Parse entering request body
         *
         * @param request
         * @param response
         * @param next
         */
        this.parseBody = (request, response, next) => {
            // Parse body as a raw string and JSON/form if applicable
            const requestContentType = request.header('Content-Type');
            // body was already parsed (e.g. by firebase), 'data' event will not be emitted (⚠️ request.body will always be an empty object in Firebase Functions, we have to check rawBody too)
            if (!!request.body && request.rawBody) {
                this.processRawBody(request, next, [request.rawBody], requestContentType);
            }
            else {
                const rawBody = [];
                request.on('data', (chunk) => {
                    rawBody.push(Buffer.from(chunk, 'binary'));
                });
                request.on('end', () => {
                    this.processRawBody(request, next, rawBody, requestContentType);
                });
            }
        };
        /**
         * ### Middleware ###
         * Emit an event when response emit the 'close' event
         *
         * @param request
         * @param response
         * @param next
         */
        this.logRequest = (request, response, next) => {
            response.on('close', () => {
                const transaction = (0, utils_1.CreateTransaction)(request, response);
                this.emit('transaction-complete', transaction);
                this.transactionLogs.push(transaction);
                // keep only the last n transactions
                if (this.transactionLogs.length > this.options.maxTransactionLogs) {
                    this.transactionLogs = this.transactionLogs.slice(this.options.maxTransactionLogs * -1);
                }
            });
            next();
        };
        /**
         * ### Middleware ###
         * Add environment headers & proxy headers to the response
         *
         * @param request
         * @param response
         * @param next
         */
        this.setResponseHeaders = (request, response, next) => {
            this.setHeaders(this.environment.headers, response, request);
            next();
        };
        /**
         * ### Middleware ###
         * Catch all error handler
         * http://expressjs.com/en/guide/error-handling.html#catching-errors
         *
         * @param server - server on which to log the response
         */
        this.errorHandler = (error, request, response, _next) => {
            this.sendError(response, error, 500);
        };
        this.options = Object.assign(Object.assign(Object.assign({}, this.options), options), { envVarsPrefix: (_a = options.envVarsPrefix) !== null && _a !== void 0 ? _a : commons_1.defaultEnvironmentVariablesPrefix });
    }
    /**
     * Start a server
     */
    start() {
        const requestListener = this.createRequestListener();
        const webSocketRoutes = (0, commons_1.routesFromFolder)(this.environment.rootChildren, this.environment.folders, this.environment.routes, this.options.disabledRoutes, [commons_1.RouteType.WS]);
        // create https or http server instance
        if (this.environment.tlsOptions.enabled && !this.options.disableTls) {
            try {
                this.tlsOptions = this.buildTLSOptions(this.environment);
                this.serverInstance = (0, https_1.createServer)(this.tlsOptions);
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    this.emit('error', commons_1.ServerErrorCodes.CERT_FILE_NOT_FOUND, error);
                }
                else {
                    this.emit('error', commons_1.ServerErrorCodes.UNKNOWN_SERVER_ERROR, error);
                }
            }
        }
        else {
            this.serverInstance = (0, http_1.createServer)();
        }
        // make serverInstance killable
        this.serverInstance = (0, killable_1.default)(this.serverInstance);
        // set timeout long enough to allow long latencies
        this.serverInstance.setTimeout(3600000);
        // handle server errors
        this.serverInstance.on('error', (error) => {
            let errorCode;
            switch (error.code) {
                case 'EADDRINUSE':
                    errorCode = commons_1.ServerErrorCodes.PORT_ALREADY_USED;
                    break;
                case 'EACCES':
                    errorCode = commons_1.ServerErrorCodes.PORT_INVALID;
                    break;
                case 'EADDRNOTAVAIL':
                    errorCode = commons_1.ServerErrorCodes.HOSTNAME_UNAVAILABLE;
                    break;
                case 'ENOTFOUND':
                    errorCode = commons_1.ServerErrorCodes.HOSTNAME_UNKNOWN;
                    break;
                default:
                    errorCode = commons_1.ServerErrorCodes.UNKNOWN_SERVER_ERROR;
            }
            this.emit('error', errorCode, error);
        });
        this.serverInstance.on('request', requestListener);
        if (webSocketRoutes.length > 0) {
            this.createWSRoutes(webSocketRoutes);
        }
        try {
            this.serverInstance.listen({ port: this.environment.port, host: this.environment.hostname }, () => {
                this.emit('started');
            });
        }
        catch (error) {
            if (error.code === 'ERR_SOCKET_BAD_PORT') {
                this.emit('error', commons_1.ServerErrorCodes.PORT_INVALID, error);
            }
        }
    }
    /**
     * Kill the server
     */
    stop() {
        if (this.webSocketServers.length > 0) {
            this.webSocketServers.forEach((webSocketServer) => {
                webSocketServer.instance.close();
            });
        }
        ws_2.BroadcastContext.getInstance().closeAll();
        if (this.serverInstance) {
            this.serverInstance.kill(() => {
                this.emit('stopped');
            });
        }
    }
    /**
     * Create a request listener
     */
    createRequestListener() {
        var _a, _b, _c, _d;
        /**
         * Apply faker.js settings at each server start.
         * Locale must be set before seed.
         * We do this in the request listener to allow changing the locale and seed from the serverless package too, which is not using the start/stop methods.
         */
        (0, faker_1.SetFakerLocale)((_b = (_a = this.options.fakerOptions) === null || _a === void 0 ? void 0 : _a.locale) !== null && _b !== void 0 ? _b : 'en');
        (0, faker_1.SetFakerSeed)((_d = (_c = this.options.fakerOptions) === null || _c === void 0 ? void 0 : _c.seed) !== null && _d !== void 0 ? _d : undefined);
        const app = (0, express_1.default)();
        app.disable('x-powered-by');
        app.disable('etag');
        app.use(this.removeExpectHeader);
        // This middleware is required to parse the body for createAdminEndpoint requests
        app.use(this.parseBody);
        if (this.options.enableAdminApi) {
            // admin endpoint must be created before all other routes to avoid conflicts
            (0, admin_api_1.createAdminEndpoint)(app, this, {
                statePurgeCallback: () => {
                    // reset request numbers
                    Object.keys(this.requestNumbers).forEach((routeUUID) => {
                        this.requestNumbers[routeUUID] = 1;
                    });
                },
                getGlobalVariables: (key) => this.globalVariables[key],
                setGlobalVariables: (key, value) => {
                    this.globalVariables[key] = value;
                },
                purgeGlobalVariables: () => {
                    this.globalVariables = {};
                },
                getDataBucket: this.getProcessedDatabucket.bind(this),
                getDataBuckets: () => this.processedDatabuckets,
                purgeDataBuckets: () => {
                    this.processedDatabuckets = [];
                    this.generateDatabuckets(this.environment);
                },
                getLogs: () => this.transactionLogs,
                purgeLogs: () => {
                    this.transactionLogs = [];
                },
                envVarsPrefix: this.options.envVarsPrefix,
                updateEnvironment: (environment) => {
                    this.environment = environment;
                }
            });
        }
        // process databuckets after admin endpoint creation to properly catch the databucket processed event
        this.generateDatabuckets(this.environment);
        app.use(this.emitEvent);
        app.use(this.delayResponse);
        app.use(this.deduplicateRequestSlashes);
        app.use((0, cookie_parser_1.default)());
        app.use(this.logRequest);
        app.use(this.setResponseHeaders);
        this.setRoutes(app);
        this.setCors(app);
        this.enableProxy(app);
        app.use(this.errorHandler);
        return app;
    }
    /**
     * Return a processed databucket by name, id, or uuid
     *
     * @param identifier
     */
    getProcessedDatabucket(identifier) {
        return this.processedDatabuckets.find((processedDatabucket) => processedDatabucket.name.toLowerCase() === identifier.toLowerCase() ||
            processedDatabucket.id === identifier.toLowerCase() ||
            processedDatabucket.uuid === identifier.toLowerCase());
    }
    /**
     * Method that can be used to update the server's environment
     *
     * @param environment
     */
    updateEnvironment(environment) {
        this.environment = environment;
    }
    /**
     * ### Middleware ###
     * Remove duplicate slashes in entering call paths
     *
     * @param request
     * @param response
     * @param next
     */
    deduplicateRequestSlashes(request, response, next) {
        request.url = (0, commons_1.dedupSlashes)(request.url);
        next();
    }
    /**
     * Process the raw body and parse it if needed
     *
     * @param request
     * @param next
     * @param rawBody
     * @param requestContentType
     */
    processRawBody(request, next, rawBody, requestContentType) {
        request.rawBody = Buffer.concat(rawBody);
        request.stringBody = request.rawBody.toString('utf8');
        try {
            if (requestContentType) {
                if ((0, commons_1.stringIncludesArrayItems)(commons_1.ParsedJSONBodyMimeTypes, requestContentType)) {
                    request.body = JSON.parse(request.stringBody);
                    next();
                }
                else if (requestContentType.includes('application/x-www-form-urlencoded')) {
                    request.body = (0, qs_1.parse)(request.stringBody, {
                        depth: 10
                    });
                    next();
                }
                else if (requestContentType.includes('multipart/form-data')) {
                    const busboyParse = (0, busboy_1.default)({
                        headers: request.headers,
                        limits: {
                            fieldNameSize: 1000,
                            files: this.options.maxFileUploads,
                            fileSize: this.options.maxFileSize
                        }
                    });
                    busboyParse.on('field', (name, value, info) => {
                        if (request.body === undefined) {
                            request.body = {};
                        }
                        if (name != null && !info.nameTruncated && !info.valueTruncated) {
                            // add support for first level array fields (e.g. multiple fields with the same name without brackets)
                            if (!name.includes('[') &&
                                request.body[name] !== undefined &&
                                !Array.isArray(request.body[name])) {
                                request.body[name] = [request.body[name]];
                                name = `${name}[]`;
                            }
                            (0, append_field_1.default)(request.body, name, value);
                        }
                    });
                    busboyParse.on('file', (name, stream, info) => {
                        if (request.body === undefined) {
                            request.body = {};
                        }
                        const file = {
                            filename: info.filename,
                            mimetype: info.mimeType,
                            size: 0
                        };
                        stream.on('data', (data) => {
                            file.size += data.length;
                        });
                        stream.on('close', () => {
                            // add support for first level array fields (e.g. multiple fields with the same name without brackets)
                            if (!name.includes('[') &&
                                request.body[name] !== undefined &&
                                !Array.isArray(request.body[name])) {
                                request.body[name] = [request.body[name]];
                                name = `${name}[]`;
                            }
                            (0, append_field_1.default)(request.body, name, file);
                        });
                    });
                    busboyParse.on('error', (error) => {
                        this.emit('error', commons_1.ServerErrorCodes.REQUEST_BODY_PARSE, error);
                        // we want to continue answering the call despite the parsing errors
                        next();
                    });
                    busboyParse.on('finish', () => {
                        next();
                    });
                    busboyParse.end(request.rawBody);
                }
                else if ((0, commons_1.stringIncludesArrayItems)(commons_1.ParsedXMLBodyMimeTypes, requestContentType)) {
                    request.body = (0, xml_js_1.xml2js)(request.stringBody, {
                        compact: true
                    });
                    next();
                }
                else {
                    next();
                }
            }
            else {
                next();
            }
        }
        catch (error) {
            this.emit('error', commons_1.ServerErrorCodes.REQUEST_BODY_PARSE, error);
            next();
        }
    }
    /**
     * Generate an environment routes and attach to running server
     *
     * @param server - server on which attach routes
     */
    setRoutes(server) {
        if (!this.environment.rootChildren ||
            this.environment.rootChildren.length < 1) {
            return;
        }
        const routes = (0, commons_1.routesFromFolder)(this.environment.rootChildren, this.environment.folders, this.environment.routes, this.options.disabledRoutes, [commons_1.RouteType.HTTP, commons_1.RouteType.CRUD]);
        routes.forEach((declaredRoute) => {
            const routePath = (0, utils_1.preparePath)(this.environment.endpointPrefix, declaredRoute.endpoint);
            try {
                this.requestNumbers[declaredRoute.uuid] = 1;
                if (declaredRoute.type === commons_1.RouteType.CRUD) {
                    this.createCRUDRoute(server, declaredRoute, routePath);
                }
                else if (declaredRoute.type === commons_1.RouteType.HTTP) {
                    this.createRESTRoute(server, declaredRoute, routePath);
                }
            }
            catch (error) {
                let errorCode = commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR;
                // if invalid regex defined
                if (error.message.indexOf('Invalid regular expression') > -1) {
                    errorCode = commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR_REGEX;
                }
                this.emit('error', errorCode, error, {
                    routePath: declaredRoute.endpoint,
                    routeUUID: declaredRoute.uuid
                });
            }
        });
    }
    /**
     * Creates websocket routes from the given set of routes.
     *
     * @param wsRoutes
     */
    createWSRoutes(wsRoutes) {
        wsRoutes.forEach((wsRoute) => {
            const webSocketServer = new ws_1.WebSocket.Server({
                noServer: true
            });
            this.webSocketServers.push({
                instance: webSocketServer,
                path: (0, utils_1.preparePath)(this.environment.endpointPrefix, wsRoute.endpoint)
            });
            webSocketServer.on('connection', this.createWebSocketConnectionHandler(webSocketServer, wsRoute));
        });
        this.serverInstance.on('upgrade', (req, socket, head) => {
            const urlParsed = (0, url_1.parse)(req.url || '', true);
            // check if the request is a websocket upgrade request
            if (req.headers.upgrade !== 'websocket') {
                socket.write(`HTTP/${req.httpVersion} 400 Bad Request\r\n`);
                socket.write('Content-Type: text/html\r\n');
                socket.write('Content-length: 72\r\n\r\n');
                socket.write('Invalid WebSocket upgrade request: "Upgrade: websocket" header not found');
                socket.destroy();
                return;
            }
            for (const wsServer of this.webSocketServers) {
                if ((0, path_to_regexp_1.match)(wsServer.path)(urlParsed.pathname || '')) {
                    wsServer.instance.handleUpgrade(req, socket, head, (client) => {
                        wsServer.instance.emit('connection', client, req);
                    });
                    return;
                }
            }
            // if no route is matched (loop didn't return), close the connection
            socket.write(`HTTP/${req.httpVersion} 404 Not Found\r\n`);
            socket.write('Content-Type: text/html\r\n');
            socket.write('Content-length: 38\r\n\r\n');
            socket.write('No WebSocket route found for this path');
            socket.destroy();
        });
    }
    /**
     * Creates a handler for a web socket connection received, if only any
     * of route is matched.
     *
     * @param webSocketServer
     * @param routeFor
     * @returns
     */
    createWebSocketConnectionHandler(webSocketServer, routeFor) {
        return (socket, request) => {
            const route = this.getRefreshedRoute(routeFor);
            if (!route) {
                this.emit('error', commons_1.ServerErrorCodes.ROUTE_NO_LONGER_EXISTS, null, {
                    routePath: routeFor.endpoint,
                    routeUUID: routeFor.uuid
                });
                return;
            }
            const websocketId = (0, commons_1.generateUUID)();
            const baseErrorMeta = {
                websocketId,
                routeUUID: route.uuid,
                routePath: route.endpoint
            };
            const inflightRequest = (0, utils_1.CreateInFlightRequest)(websocketId, request, route);
            this.emit('ws-new-connection', inflightRequest);
            let responseNumber = 1;
            // handle error event
            socket.on('error', (err) => {
                this.emit('error', commons_1.ServerErrorCodes.WS_SERVING_ERROR, err, baseErrorMeta);
            });
            // handle common close method.
            // There would be more close methods registered, if the route is in streaming mode.
            socket.on('close', (code, reason) => {
                this.emit('ws-closed', inflightRequest, code, reason ? reason.toString('utf8') : null);
            });
            const serverRequest = (0, requests_1.fromWsRequest)(request, route);
            // This is not waiting until a message from client. But will push messages as a stream.
            if (route.streamingMode === commons_1.StreamingMode.BROADCAST) {
                this.handleBroadcastResponse(webSocketServer, socket, route, serverRequest, baseErrorMeta);
                return;
            }
            else if (route.streamingMode === commons_1.StreamingMode.UNICAST) {
                this.handleOneToOneStreamingResponses(socket, route, request, baseErrorMeta);
                return;
            }
            socket.on('message', (data, isBinary) => {
                if (isBinary) {
                    this.emit('error', commons_1.ServerErrorCodes.WS_UNSUPPORTED_CONTENT, null, baseErrorMeta);
                    return;
                }
                const routeInMessage = this.getRefreshedRoute(route);
                // the route is not found. Skip reacting.
                if (!routeInMessage) {
                    this.emit('error', commons_1.ServerErrorCodes.WS_UNKNOWN_ROUTE, null, baseErrorMeta);
                    return;
                }
                // get the incoming message as string...
                const messageData = (0, ws_2.messageToString)(data);
                this.emit('ws-message-received', inflightRequest, messageData);
                const enabledRouteResponse = new response_rules_interpreter_1.ResponseRulesInterpreter(routeInMessage.responses, serverRequest, routeInMessage.responseMode, this.environment, this.processedDatabuckets, this.globalVariables, this.options.envVarsPrefix, this.options.publicBaseUrl).chooseResponse(responseNumber, messageData);
                if (!enabledRouteResponse) {
                    // Do nothing?
                    return;
                }
                responseNumber += 1;
                setTimeout(() => {
                    const content = this.deriveFinalResponseContentForWebSockets(socket, routeInMessage, enabledRouteResponse, request, messageData);
                    if (content) {
                        socket.send(content || '', (err) => {
                            if (err) {
                                this.emit('error', commons_1.ServerErrorCodes.WS_SERVING_ERROR, err, Object.assign(Object.assign({}, baseErrorMeta), { selectedResponseUUID: enabledRouteResponse.uuid, selectedResponseLabel: enabledRouteResponse.label }));
                            }
                        });
                    }
                }, enabledRouteResponse.latency);
            });
        };
    }
    /**
     * Derive final delivery content for websocket response.
     *
     * If no content is returned, that means the relevant content has been served,
     * or a failure has occurred. These scenarios can happen with file body type
     * and should be handled properly by the callers.
     *
     * @param socket
     * @param route
     * @param enabledRouteResponse
     * @param request
     * @param data
     */
    deriveFinalResponseContentForWebSockets(socket, route, enabledRouteResponse, request, data, connectedRequest) {
        let content = enabledRouteResponse.body;
        let finalRequest = connectedRequest;
        finalRequest !== null && finalRequest !== void 0 ? finalRequest : (finalRequest = request ? (0, requests_1.fromWsRequest)(request, route, data) : undefined);
        if (enabledRouteResponse.bodyType === commons_1.BodyTypes.DATABUCKET &&
            enabledRouteResponse.databucketID) {
            const servedDatabucket = this.processedDatabuckets.find((processedDatabucket) => processedDatabucket.id === enabledRouteResponse.databucketID);
            if (servedDatabucket) {
                content = servedDatabucket.value;
                if (Array.isArray(content) ||
                    typeof content === 'object' ||
                    typeof content === 'boolean' ||
                    typeof content === 'number') {
                    content = JSON.stringify(content);
                }
            }
        }
        else if (enabledRouteResponse.bodyType === commons_1.BodyTypes.FILE &&
            enabledRouteResponse.filePath) {
            const filePath = this.getSafeFilePath(enabledRouteResponse.filePath, finalRequest);
            (0, ws_2.serveFileContentInWs)(socket, route, enabledRouteResponse, this, filePath, (contentData) => (0, template_parser_1.TemplateParser)({
                shouldOmitDataHelper: false,
                content: contentData,
                environment: this.environment,
                processedDatabuckets: this.processedDatabuckets,
                globalVariables: this.globalVariables,
                request: finalRequest,
                envVarsPrefix: this.options.envVarsPrefix,
                publicBaseUrl: this.options.publicBaseUrl
            }));
            return;
        }
        if (!enabledRouteResponse.disableTemplating) {
            content = (0, template_parser_1.TemplateParser)({
                shouldOmitDataHelper: false,
                content: content || '',
                environment: this.environment,
                processedDatabuckets: this.processedDatabuckets,
                globalVariables: this.globalVariables,
                request: finalRequest,
                envVarsPrefix: this.options.envVarsPrefix,
                publicBaseUrl: this.options.publicBaseUrl
            });
        }
        return content;
    }
    handleBroadcastResponse(webSocketServer, socket, route, request, baseErrorMeta) {
        const broadcastContext = ws_2.BroadcastContext.getInstance();
        const handler = (_, enabledRouteResponse) => {
            // todo: do we need to take params from initial connection at all?
            const content = this.deriveFinalResponseContentForWebSockets(socket, route, enabledRouteResponse, undefined, undefined, request) || '';
            if (!content) {
                return;
            }
            const errorMetaData = Object.assign(Object.assign({}, baseErrorMeta), { selectedResponseUUID: enabledRouteResponse.uuid, selectedResponseLabel: enabledRouteResponse.label });
            webSocketServer.clients.forEach((client) => {
                if ((0, ws_2.isWebSocketOpen)(client)) {
                    this.serveWsResponse(client, content, errorMetaData);
                }
            });
        };
        broadcastContext.registerRoute(route, {
            environment: this.environment,
            processedDatabuckets: this.processedDatabuckets,
            globalVariables: this.globalVariables,
            envVarPrefix: this.options.envVarsPrefix,
            publicBaseUrl: this.options.publicBaseUrl
        }, request, handler);
    }
    /**
     * Handle streaming websocket responses.
     *
     * @param socket
     * @param route
     * @param request
     * @param baseErrorMeta
     */
    handleOneToOneStreamingResponses(socket, route, request, baseErrorMeta) {
        let responseNumber = 1;
        const intervalRef = setInterval(() => {
            const enabledRouteResponse = new response_rules_interpreter_1.ResponseRulesInterpreter(route.responses, (0, requests_1.fromWsRequest)(request, route), route.responseMode, this.environment, this.processedDatabuckets, this.globalVariables, this.options.envVarsPrefix, this.options.publicBaseUrl).chooseResponse(responseNumber);
            if (!enabledRouteResponse) {
                return;
            }
            const content = this.deriveFinalResponseContentForWebSockets(socket, route, enabledRouteResponse, request) || '';
            responseNumber += 1;
            if (!content) {
                return;
            }
            const errorMetaData = Object.assign(Object.assign({}, baseErrorMeta), { selectedResponseUUID: enabledRouteResponse.uuid, selectedResponseLabel: enabledRouteResponse.label });
            if (route.streamingMode === commons_1.StreamingMode.UNICAST) {
                if ((0, ws_2.isWebSocketOpen)(socket)) {
                    this.serveWsResponse(socket, content, errorMetaData);
                }
            }
        }, (0, ws_2.getSafeStreamingInterval)(route.streamingInterval));
        socket.on('close', () => {
            // close any interval data pushes
            if (intervalRef) {
                clearInterval(intervalRef);
            }
        });
    }
    /**
     * Sends given response data to the socket client.
     *
     * @param client
     * @param content
     * @param errorMetaData
     */
    serveWsResponse(client, content, errorMetaData) {
        client.send(content, (err) => {
            if (err) {
                this.emit('error', commons_1.ServerErrorCodes.WS_SERVING_ERROR, err, errorMetaData);
            }
        });
    }
    /**
     * Create a regular REST route (GET, POST, etc.)
     *
     * @param server
     * @param route
     * @param routePath
     */
    createRESTRoute(server, route, routePath) {
        server[route.method](routePath, this.createRouteHandler(route));
    }
    /**
     * Create a CRUD route: GET, POST, PUT, PATCH, DELETE
     *
     * @param server
     * @param route
     * @param routePath
     */
    createCRUDRoute(server, route, routePath) {
        const crudRoutes = (0, commons_1.crudRoutesBuilder)(routePath);
        for (const crudRoute of crudRoutes) {
            server[crudRoute.method](crudRoute.path, this.createRouteHandler(route, crudRoute.id));
        }
    }
    createRouteHandler(route, crudId) {
        return (request, response, next) => {
            this.generateRequestDatabuckets(route, this.environment, request);
            // refresh environment data to get route changes that do not require a restart (headers, body, etc)
            const currentRoute = this.getRefreshedRoute(route);
            if (!currentRoute) {
                this.emit('error', commons_1.ServerErrorCodes.ROUTE_NO_LONGER_EXISTS, null, {
                    routePath: route.endpoint,
                    routeUUID: route.uuid
                });
                this.sendError(response, server_messages_constants_1.ServerMessages.ROUTE_NO_LONGER_EXISTS, 404);
                return;
            }
            const enabledRouteResponse = new response_rules_interpreter_1.ResponseRulesInterpreter(currentRoute.responses, (0, requests_1.fromExpressRequest)(request), currentRoute.responseMode, this.environment, this.processedDatabuckets, this.globalVariables, this.options.envVarsPrefix, this.options.publicBaseUrl).chooseResponse(this.requestNumbers[route.uuid]);
            if (!enabledRouteResponse) {
                return next();
            }
            this.requestNumbers[route.uuid] += 1;
            // save route and response UUIDs for logs (only in desktop app)
            if (route.uuid && enabledRouteResponse.uuid) {
                response.routeUUID = route.uuid;
                response.routeResponseUUID = enabledRouteResponse.uuid;
            }
            const latency = (0, commons_1.getLatency)(enabledRouteResponse.latency, this.options.enableRandomLatency);
            // add route latency if any
            setTimeout(() => {
                const contentType = (0, commons_1.GetRouteResponseContentType)(this.environment, enabledRouteResponse);
                const routeContentType = (0, commons_1.GetContentType)(enabledRouteResponse.headers);
                // set http code
                response.status(enabledRouteResponse.statusCode);
                this.setHeaders(enabledRouteResponse.headers, response, request);
                // send the file
                if (enabledRouteResponse.bodyType === commons_1.BodyTypes.FILE &&
                    enabledRouteResponse.filePath) {
                    this.sendFile(route, enabledRouteResponse, routeContentType, request, response);
                    // serve inline body or databucket
                }
                else {
                    let templateParse = true;
                    if (contentType.includes('application/json')) {
                        response.set('Content-Type', 'application/json');
                    }
                    // serve inline body as default
                    let content = enabledRouteResponse.body;
                    if (enabledRouteResponse.bodyType === commons_1.BodyTypes.DATABUCKET &&
                        enabledRouteResponse.databucketID) {
                        // databuckets are parsed at the server start or beginning of first request execution (no need to parse templating again)
                        templateParse = false;
                        const servedDatabucket = this.processedDatabuckets.find((processedDatabucket) => processedDatabucket.id === enabledRouteResponse.databucketID);
                        if (servedDatabucket) {
                            content = servedDatabucket.value;
                            if (route.type === commons_1.RouteType.CRUD && crudId) {
                                content = (0, crud_1.databucketActions)(crudId, servedDatabucket, request, response, currentRoute.responses[0].crudKey);
                            }
                            // if returned content is an array or object we need to stringify it for some values (array, object, booleans and numbers (bool and nb because expressjs cannot serve this as is))
                            if (Array.isArray(content) ||
                                typeof content === 'object' ||
                                typeof content === 'boolean' ||
                                typeof content === 'number') {
                                content = JSON.stringify(content);
                            }
                        }
                    }
                    this.serveBody(content || '', route, enabledRouteResponse, request, response, templateParse);
                }
            }, latency);
        };
    }
    executeCallbacks(routeResponse, request, response) {
        // avoid infinite callback loops by tracking the chain of callback triggers
        const incomingCallbackChain = request.header('X-Mockoon-Callback-Chain') || '';
        const callbackChainArray = incomingCallbackChain
            ? incomingCallbackChain.split(',')
            : [];
        // check if current route response is already in the callback chain
        if (callbackChainArray.includes(routeResponse.uuid)) {
            this.emit('error', commons_1.ServerErrorCodes.CALLBACK_ERROR, new Error('Infinite callback loop detected'), {
                routeResponseUUID: routeResponse.uuid,
                callbackChain: incomingCallbackChain
            });
            return;
        }
        if (routeResponse.callbacks && routeResponse.callbacks.length > 0) {
            const serverRequest = (0, requests_1.fromExpressRequest)(request);
            for (const callbackInvocation of routeResponse.callbacks) {
                const callback = this.environment.callbacks.find((ref) => ref.uuid === callbackInvocation.uuid);
                if (!callback) {
                    continue;
                }
                try {
                    let url = (0, template_parser_1.TemplateParser)({
                        shouldOmitDataHelper: false,
                        content: callback.uri,
                        environment: this.environment,
                        processedDatabuckets: this.processedDatabuckets,
                        globalVariables: this.globalVariables,
                        request: serverRequest,
                        response,
                        envVarsPrefix: this.options.envVarsPrefix,
                        publicBaseUrl: this.options.publicBaseUrl
                    });
                    // build the callback chain by appending current route response UUID
                    const newCallbackChain = [
                        ...callbackChainArray,
                        routeResponse.uuid
                    ].join(',');
                    const extraHeaders = {
                        'X-Mockoon-Callback-Chain': newCallbackChain
                    };
                    // detect if relative URL and add current host and protocol
                    if (url.startsWith('/')) {
                        const serverAddress = this.serverInstance.address();
                        const hostname = this.options.publicBaseUrl ||
                            `${this.environment.tlsOptions.enabled ? 'https' : 'http'}://${(0, node_net_1.isIPv6)(serverAddress.address) ? `[${serverAddress.address}]` : serverAddress.address}:${serverAddress.port}`;
                        url = `${hostname}${this.environment.endpointPrefix ? '/' + this.environment.endpointPrefix : ''}${url}`;
                    }
                    const fileServingError = (error) => {
                        this.emit('error', commons_1.ServerErrorCodes.CALLBACK_FILE_ERROR, error, {
                            callbackName: callback.name
                        });
                    };
                    let content = callback.body;
                    let templateParse = true;
                    const sendingHeaders = {
                        headers: {}
                    };
                    this.setHeaders(callback.headers || [], sendingHeaders, request);
                    if (callback.bodyType === commons_1.BodyTypes.DATABUCKET &&
                        callback.databucketID) {
                        templateParse = false;
                        const servedDatabucket = this.processedDatabuckets.find((processedDatabucket) => processedDatabucket.id === callback.databucketID);
                        if (servedDatabucket) {
                            content = servedDatabucket.value;
                            // if returned content is an array or object we need to stringify it for some values (array, object, booleans and numbers (bool and nb because expressjs cannot serve this as is))
                            if (Array.isArray(content) ||
                                typeof content === 'object' ||
                                typeof content === 'boolean' ||
                                typeof content === 'number') {
                                content = JSON.stringify(content);
                            }
                        }
                    }
                    else if (callback.bodyType === commons_1.BodyTypes.FILE &&
                        callback.filePath) {
                        try {
                            const filePath = this.getSafeFilePath(callback.filePath, serverRequest);
                            const fileMimeType = (0, utils_1.mimeTypeLookup)(filePath) || '';
                            const definedContentType = sendingHeaders.headers['Content-Type'];
                            if (callback.sendFileAsBody) {
                                const data = (0, fs_1.readFileSync)(filePath);
                                content = data.toString();
                                if (!commons_1.MimeTypesWithTemplating.includes(fileMimeType)) {
                                    templateParse = false;
                                }
                                // set content-type the detected mime type if any
                                if (!definedContentType && fileMimeType) {
                                    sendingHeaders.headers['Content-Type'] = fileMimeType;
                                }
                            }
                            else {
                                templateParse = false;
                                const buffer = (0, fs_1.readFileSync)(filePath);
                                content = new FormData();
                                content.append('file', new Blob([buffer]));
                            }
                        }
                        catch (error) {
                            fileServingError(error);
                            continue;
                        }
                    }
                    // apply templating if specified
                    if (!routeResponse.disableTemplating && templateParse) {
                        content = (0, template_parser_1.TemplateParser)({
                            shouldOmitDataHelper: false,
                            content: content || '',
                            environment: this.environment,
                            processedDatabuckets: this.processedDatabuckets,
                            globalVariables: this.globalVariables,
                            request: serverRequest,
                            response,
                            envVarsPrefix: this.options.envVarsPrefix,
                            publicBaseUrl: this.options.publicBaseUrl
                        });
                    }
                    setTimeout(() => {
                        fetch(url, {
                            // uppercase even if most methods will work in lower case, but PATCH has to be uppercase or could be rejected by some servers (Node.js)
                            method: callback.method.toUpperCase(),
                            headers: Object.assign(Object.assign({}, sendingHeaders.headers), extraHeaders),
                            body: (0, utils_1.isBodySupportingMethod)(callback.method)
                                ? content
                                : undefined
                        })
                            .then((res) => {
                            this.emitCallbackInvoked(res, callback, url, content instanceof FormData
                                ? `<buffer of ${callback.filePath}`
                                : content, sendingHeaders.headers);
                        })
                            .catch((e) => this.emit('error', commons_1.ServerErrorCodes.CALLBACK_ERROR, e, {
                            callbackName: callback.name
                        }));
                    }, callbackInvocation.latency);
                }
                catch (error) {
                    this.emit('error', commons_1.ServerErrorCodes.CALLBACK_ERROR, error, {
                        callbackName: callback.name
                    });
                }
            }
        }
    }
    /**
     * Parse the body templating and send it as the response body
     *
     * @param routeResponse
     * @param request
     * @param response
     */
    serveBody(content, route, routeResponse, request, response, templateParse = true) {
        try {
            if (!routeResponse.disableTemplating && templateParse) {
                content = (0, template_parser_1.TemplateParser)({
                    shouldOmitDataHelper: false,
                    content: content || '',
                    environment: this.environment,
                    processedDatabuckets: this.processedDatabuckets,
                    globalVariables: this.globalVariables,
                    request: (0, requests_1.fromExpressRequest)(request),
                    response,
                    envVarsPrefix: this.options.envVarsPrefix,
                    publicBaseUrl: this.options.publicBaseUrl
                });
            }
            this.applyResponseLocals(response);
            response.body = content;
            // execute callbacks after generating the template, to be able to use the eventual templating variables in the callback
            this.executeCallbacks(routeResponse, request, response);
            response.send(content);
        }
        catch (error) {
            this.emit('error', commons_1.ServerErrorCodes.ROUTE_SERVING_ERROR, error, {
                routePath: route.endpoint,
                routeUUID: route.uuid
            });
            this.sendError(response, (0, util_1.format)(server_messages_constants_1.ServerMessages.ROUTE_SERVING_ERROR, error.message));
        }
    }
    /**
     * Send a file as response body.
     * Revert to sendBody if file is not found.
     *
     * @param routeResponse
     * @param routeContentType
     * @param request
     * @param response
     */
    sendFile(route, routeResponse, routeContentType, request, response) {
        const fileServingError = (error) => {
            this.emit('error', commons_1.ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, error, {
                routePath: route.endpoint,
                routeUUID: route.uuid
            });
            this.sendError(response, (0, util_1.format)(server_messages_constants_1.ServerMessages.ROUTE_FILE_SERVING_ERROR, error.message));
        };
        const errorThrowOrFallback = (error) => {
            if (routeResponse.fallbackTo404) {
                response.status(404);
                const content = routeResponse.body ? routeResponse.body : '';
                this.serveBody(content, route, routeResponse, request, response);
            }
            else {
                fileServingError(error);
            }
        };
        const serverRequest = (0, requests_1.fromExpressRequest)(request);
        try {
            const filePath = this.getSafeFilePath(routeResponse.filePath, serverRequest);
            const fileMimeType = (0, utils_1.mimeTypeLookup)(filePath) || '';
            // set content-type the detected mime type if any
            if (!routeContentType && fileMimeType) {
                response.set('Content-Type', fileMimeType);
            }
            if (!routeResponse.sendFileAsBody) {
                response.set('Content-Disposition', `attachment; filename="${encodeURIComponent((0, path_1.basename)(filePath))}"`);
            }
            // parse templating for a limited list of mime types
            if ((commons_1.MimeTypesWithTemplating.includes(fileMimeType) ||
                commons_1.FileExtensionsWithTemplating.includes((0, path_1.extname)(filePath))) &&
                !routeResponse.disableTemplating) {
                (0, fs_1.readFile)(filePath, (readError, data) => {
                    if (readError) {
                        errorThrowOrFallback(readError);
                        return;
                    }
                    try {
                        const fileContent = (0, template_parser_1.TemplateParser)({
                            shouldOmitDataHelper: false,
                            content: data.toString(),
                            environment: this.environment,
                            processedDatabuckets: this.processedDatabuckets,
                            globalVariables: this.globalVariables,
                            request: serverRequest,
                            response,
                            envVarsPrefix: this.options.envVarsPrefix,
                            publicBaseUrl: this.options.publicBaseUrl
                        });
                        this.applyResponseLocals(response);
                        response.body = fileContent;
                        // execute callbacks after generating the file content, to be able to use the eventual templating variables in the callback
                        this.executeCallbacks(routeResponse, request, response);
                        response.send(fileContent);
                    }
                    catch (error) {
                        fileServingError(error);
                    }
                });
            }
            else {
                try {
                    const rangeHeader = request.headers.range;
                    const { size } = (0, fs_1.statSync)(filePath);
                    response.body = commons_1.BINARY_BODY;
                    let stream = (0, fs_1.createReadStream)(filePath);
                    this.setHeaders([
                        {
                            key: 'Content-Length',
                            value: size.toString()
                        }
                    ], response, request);
                    if (rangeHeader) {
                        const parsedRange = (0, range_parser_1.default)(size, rangeHeader);
                        // unsatisfiable range
                        if (parsedRange === -1) {
                            this.sendError(response, 'Requested range not satisfiable', 416);
                            return;
                        }
                        else if (parsedRange === -2) {
                            // malformed header
                            this.sendError(response, 'Malformed range header', 400);
                            return;
                        }
                        else if (parsedRange) {
                            const start = parsedRange[0].start;
                            const end = parsedRange[0].end;
                            const chunksize = end - start + 1;
                            stream = (0, fs_1.createReadStream)(filePath, { start, end });
                            this.setHeaders([
                                {
                                    key: 'Content-Range',
                                    value: `bytes ${start}-${end}/${size}`
                                },
                                {
                                    key: 'Accept-Ranges',
                                    value: 'bytes'
                                },
                                {
                                    key: 'Content-Length',
                                    value: chunksize.toString()
                                },
                                {
                                    key: 'Content-Type',
                                    value: fileMimeType
                                }
                            ], response, request);
                            response.status(206);
                            stream = (0, fs_1.createReadStream)(filePath, { start, end });
                        }
                    }
                    this.executeCallbacks(routeResponse, request, response);
                    stream.pipe(response);
                }
                catch (error) {
                    errorThrowOrFallback(error);
                }
            }
        }
        catch (error) {
            this.emit('error', commons_1.ServerErrorCodes.ROUTE_SERVING_ERROR, error, {
                routePath: route.endpoint,
                routeUUID: route.uuid
            });
            this.sendError(response, (0, util_1.format)(server_messages_constants_1.ServerMessages.ROUTE_SERVING_ERROR, error.message));
        }
    }
    /**
     * Always answer with status 200 to CORS pre flight OPTIONS requests if option activated.
     * /!\ Must be called after the routes creation otherwise it will intercept all user defined OPTIONS routes.
     *
     * @param server - express instance
     */
    setCors(server) {
        if (this.environment.cors) {
            server.options('/*', (req, res) => {
                // override default CORS headers with environment's headers
                this.setHeaders([...commons_1.CORSHeaders, ...this.environment.headers], res, req);
                res.status(200).end();
            });
        }
    }
    /**
     * Add catch-all proxy if enabled.
     * Restream the body to the proxied API because it already has been
     * intercepted by the body parser.
     *
     * @param server - server on which to launch the proxy
     */
    enableProxy(server) {
        if (this.environment.proxyMode &&
            this.environment.proxyHost &&
            (0, commons_1.IsValidURL)(this.environment.proxyHost)) {
            this.emit('creating-proxy');
            server.use((0, http_proxy_middleware_1.createProxyMiddleware)({
                cookieDomainRewrite: { '*': '' },
                target: this.environment.proxyHost,
                secure: false,
                changeOrigin: true,
                pathRewrite: (path) => {
                    if (this.environment.proxyRemovePrefix === true &&
                        this.environment.endpointPrefix.length > 0) {
                        const regExp = new RegExp(`^/${this.environment.endpointPrefix}`);
                        return path.replace(regExp, '');
                    }
                    return path;
                },
                ssl: Object.assign(Object.assign({}, this.tlsOptions), { agent: false }),
                on: {
                    proxyReq: (proxyReq, request) => {
                        request.proxied = true;
                        this.setHeaders(this.environment.proxyReqHeaders, proxyReq, request);
                        // re-stream the body (intercepted by body parser method)
                        if (request.rawBody) {
                            proxyReq.write(request.rawBody);
                        }
                    },
                    proxyRes: (proxyRes, request, response) => {
                        const buffers = [];
                        proxyRes.on('data', (chunk) => {
                            buffers.push(chunk);
                        });
                        proxyRes.on('end', () => {
                            response.body = Buffer.concat(buffers);
                        });
                        this.setHeaders(this.environment.proxyResHeaders, proxyRes, request);
                    },
                    error: (error, request, response) => {
                        this.emit('error', commons_1.ServerErrorCodes.PROXY_ERROR, error);
                        this.sendError(response, `${(0, util_1.format)(server_messages_constants_1.ServerMessages.PROXY_ERROR, this.environment.proxyHost)} ${request.url}: ${error}`, 504);
                    }
                }
            }));
        }
    }
    /**
     * Set the provided headers on the target. Use different headers accessors
     * depending on the type of target:
     * express.Response/http.OutgoingMessage/http.IncomingMessage
     * Use the source in the template parsing of each header value.
     *
     * @param headers
     * @param target
     * @param request
     */
    setHeaders(headers, target, request) {
        headers.forEach((header) => {
            try {
                const isSetCookie = header.key.toLowerCase() === 'set-cookie';
                let parsedHeaderValue = this.parseHeader(header, request);
                if (parsedHeaderValue === null) {
                    return;
                }
                if (target.set) {
                    // for express.Response
                    if (isSetCookie) {
                        target.append(header.key, parsedHeaderValue);
                    }
                    else {
                        target.set(header.key, parsedHeaderValue);
                    }
                }
                else if (target.setHeader) {
                    // for proxy http.OutgoingMessage | ClientRequest
                    target.setHeader(header.key, parsedHeaderValue);
                }
                else {
                    // for http.IncomingMessage
                    if (isSetCookie) {
                        // Remove the secure flag
                        parsedHeaderValue = parsedHeaderValue.replace(/; secure/gi, '');
                        target.headers[header.key] = this.appendHeaderValue(target.headers[header.key], parsedHeaderValue);
                    }
                    else {
                        target.headers[header.key] = parsedHeaderValue;
                    }
                }
            }
            catch (_error) { }
        });
    }
    /**
     * If header already has a value, concatenate the values into an array
     *
     * @param currentValue
     * @param newValue
     * @returns
     */
    appendHeaderValue(currentValue, newValue) {
        let headerValue = newValue;
        if (currentValue) {
            headerValue = Array.isArray(currentValue)
                ? currentValue.concat(headerValue)
                : [currentValue, headerValue];
        }
        return headerValue;
    }
    /**
     * Verify a header validity and parse its content, if templating is used
     *
     * @param header
     * @param request
     * @returns
     */
    parseHeader(header, request) {
        let parsedHeaderValue = null;
        if (header.key && header.value) {
            try {
                parsedHeaderValue = (0, template_parser_1.TemplateParser)({
                    shouldOmitDataHelper: false,
                    content: header.value,
                    environment: this.environment,
                    processedDatabuckets: this.processedDatabuckets,
                    globalVariables: this.globalVariables,
                    request: (0, requests_1.fromExpressRequest)(request),
                    envVarsPrefix: this.options.envVarsPrefix,
                    publicBaseUrl: this.options.publicBaseUrl
                });
            }
            catch (error) {
                this.emit('error', commons_1.ServerErrorCodes.HEADER_PARSING_ERROR, error, {
                    headerKey: header.key,
                    headerValue: header.value
                });
                parsedHeaderValue = server_messages_constants_1.ServerMessages.HEADER_PARSING_ERROR_LIGHT;
            }
        }
        return parsedHeaderValue;
    }
    /**
     * Send an error with text/plain content type, the provided message and status code.
     * Status is optional. No status will default to the one defined by the user, allowing for maximum customization.
     *
     * @param response
     * @param errorMessage
     * @param status
     */
    sendError(response, errorMessage, status) {
        response.set('Content-Type', 'text/plain');
        response.body = errorMessage;
        if (errorMessage instanceof Error) {
            errorMessage = errorMessage.message;
        }
        if (status !== undefined) {
            response.status(status);
        }
        response.send(errorMessage);
    }
    /**
     * Emit callback invoked event.
     *
     * @param res
     * @param callback
     * @param url
     * @param requestBody
     * @param requestHeaders
     */
    emitCallbackInvoked(res, callback, url, requestBody, requestHeaders) {
        res.text().then((respText) => {
            const reqHeaders = Object.keys(requestHeaders).map((k) => ({ key: k, value: requestHeaders[k] }));
            this.emit('callback-invoked', (0, utils_1.CreateCallbackInvocation)(callback, url, requestBody, reqHeaders, res, respText));
        });
    }
    /**
     * Fetch the updated route as some parameters can be applied without a restart (latency, headers, etc)
     *
     * @param routeUUID
     */
    getRefreshedRoute(currentRoute) {
        return this.environment.routes.find((route) => route.uuid === currentRoute.uuid);
    }
    /**
     * Build the secure context options
     * - if custom cert are provided load them
     * - if not, use default TLS cert (self-signed)
     *
     * @returns
     */
    buildTLSOptions(environment) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        let tlsOptions = {};
        const processTemplating = (content) => (0, template_parser_1.TemplateParser)({
            content,
            shouldOmitDataHelper: false,
            environment,
            processedDatabuckets: this.processedDatabuckets,
            globalVariables: this.globalVariables,
            envVarsPrefix: this.options.envVarsPrefix,
            publicBaseUrl: this.options.publicBaseUrl
        });
        if (((_a = environment.tlsOptions) === null || _a === void 0 ? void 0 : _a.pfxPath) ||
            (((_b = environment.tlsOptions) === null || _b === void 0 ? void 0 : _b.certPath) && ((_c = environment.tlsOptions) === null || _c === void 0 ? void 0 : _c.keyPath))) {
            if (((_d = environment.tlsOptions) === null || _d === void 0 ? void 0 : _d.type) === 'PFX' &&
                ((_e = environment.tlsOptions) === null || _e === void 0 ? void 0 : _e.pfxPath)) {
                tlsOptions.pfx = (0, fs_1.readFileSync)((0, utils_1.resolvePathFromEnvironment)(processTemplating((_f = environment.tlsOptions) === null || _f === void 0 ? void 0 : _f.pfxPath), this.options.environmentDirectory));
            }
            else if (((_g = environment.tlsOptions) === null || _g === void 0 ? void 0 : _g.type) === 'CERT' &&
                ((_h = environment.tlsOptions) === null || _h === void 0 ? void 0 : _h.certPath) &&
                ((_j = environment.tlsOptions) === null || _j === void 0 ? void 0 : _j.keyPath)) {
                tlsOptions.cert = (0, fs_1.readFileSync)((0, utils_1.resolvePathFromEnvironment)(processTemplating((_k = environment.tlsOptions) === null || _k === void 0 ? void 0 : _k.certPath), this.options.environmentDirectory));
                tlsOptions.key = (0, fs_1.readFileSync)((0, utils_1.resolvePathFromEnvironment)(processTemplating((_l = environment.tlsOptions) === null || _l === void 0 ? void 0 : _l.keyPath), this.options.environmentDirectory));
            }
            if ((_m = environment.tlsOptions) === null || _m === void 0 ? void 0 : _m.caPath) {
                tlsOptions.ca = (0, fs_1.readFileSync)((0, utils_1.resolvePathFromEnvironment)(processTemplating((_o = environment.tlsOptions) === null || _o === void 0 ? void 0 : _o.caPath), this.options.environmentDirectory));
            }
            if ((_p = environment.tlsOptions) === null || _p === void 0 ? void 0 : _p.passphrase) {
                tlsOptions.passphrase = processTemplating((_q = environment.tlsOptions) === null || _q === void 0 ? void 0 : _q.passphrase);
            }
        }
        else {
            tlsOptions = Object.assign({}, ssl_constants_1.DefaultTLSOptions);
        }
        return tlsOptions;
    }
    /**
     * Parse all databuckets in the environment and set their parsed value to true except if they contain request helpers
     * @param environment
     */
    generateDatabuckets(environment) {
        if (environment.data.length > 0) {
            environment.data.forEach((databucket) => {
                let newProcessedDatabucket;
                if (new RegExp(`{{2,3}[#(~\\s\\w ]*((?<![\\w])${request_helpers_1.requestHelperNames.join('|')})[)} ~]+`).exec(databucket.value)) {
                    // a request helper was found
                    newProcessedDatabucket = {
                        uuid: databucket.uuid,
                        id: databucket.id,
                        name: databucket.name,
                        value: databucket.value,
                        parsed: false,
                        validJson: false
                    };
                }
                else {
                    let templateParsedContent;
                    try {
                        templateParsedContent = (0, template_parser_1.TemplateParser)({
                            shouldOmitDataHelper: false,
                            content: databucket.value,
                            environment,
                            processedDatabuckets: this.processedDatabuckets,
                            globalVariables: this.globalVariables,
                            envVarsPrefix: this.options.envVarsPrefix,
                            publicBaseUrl: this.options.publicBaseUrl
                        });
                        const JSONParsedContent = JSON.parse(templateParsedContent);
                        newProcessedDatabucket = {
                            uuid: databucket.uuid,
                            id: databucket.id,
                            name: databucket.name,
                            value: JSONParsedContent,
                            parsed: true,
                            validJson: true
                        };
                    }
                    catch (error) {
                        if (error instanceof SyntaxError) {
                            newProcessedDatabucket = {
                                uuid: databucket.uuid,
                                id: databucket.id,
                                name: databucket.name,
                                value: templateParsedContent,
                                parsed: true,
                                validJson: false
                            };
                        }
                        else {
                            newProcessedDatabucket = {
                                uuid: databucket.uuid,
                                id: databucket.id,
                                name: databucket.name,
                                value: error.message,
                                parsed: true,
                                validJson: false
                            };
                        }
                    }
                }
                this.processedDatabuckets.push(newProcessedDatabucket);
            });
            this.emitProcessedDatabuckets();
        }
    }
    /**
     * Returns list of matched databucket ids in the given text.
     *
     * @param data text to be searched for possible databucket ids
     */
    extractDatabucketIdsFromString(text) {
        const matches = text === null || text === void 0 ? void 0 : text.matchAll(new RegExp('data(?:Raw)? +[\'|"]{1}([^(\'|")]*)', 'g'));
        return [...(matches !== null && matches !== void 0 ? matches : [])].map((mtc) => mtc[1]);
    }
    /**
     * Find and returns all unique databucket ids specified in callbacks
     * of the given response.
     * To achieve null safety, this will always return an empty set if no callbacks
     * have been defined.
     *
     * @param response
     * @param environment
     */
    findDatabucketIdsInCallbacks(response, environment) {
        let dataBucketIds = [];
        if (response.callbacks && response.callbacks.length > 0) {
            for (const invocation of response.callbacks) {
                const callback = environment.callbacks.find((envCallback) => envCallback.uuid === invocation.uuid);
                if (!callback) {
                    continue;
                }
                dataBucketIds = [
                    ...dataBucketIds,
                    ...this.extractDatabucketIdsFromString(callback.uri),
                    ...this.extractDatabucketIdsFromString(callback.body),
                    ...this.extractDatabucketIdsFromString(callback.filePath),
                    ...this.findDatabucketIdsInHeaders(callback.headers)
                ];
                if (callback.databucketID) {
                    dataBucketIds.push(callback.databucketID);
                }
            }
        }
        return dataBucketIds;
    }
    /**
     * Find data buckets referenced in the provided headers
     *
     * @param headers
     */
    findDatabucketIdsInHeaders(headers) {
        return headers.reduce((acc, header) => [
            ...acc,
            ...this.extractDatabucketIdsFromString(header.value)
        ], []);
    }
    /**
     * Find databucket ids in the rules target and value of the given response
     *
     * @param response
     */
    findDatabucketIdsInRules(response) {
        let dataBucketIds = [];
        response.rules.forEach((rule) => {
            const splitRules = rule.modifier.split('.');
            if (rule.target === 'data_bucket') {
                dataBucketIds = [
                    ...dataBucketIds,
                    // split by dots, take first section, or second if first is a dollar
                    splitRules[0].startsWith('$') ? splitRules[1] : splitRules[0],
                    ...this.extractDatabucketIdsFromString(rule.value)
                ];
            }
        });
        return dataBucketIds;
    }
    /**
     * Generate the databuckets that were not parsed at the server start
     *
     * @param route
     * @param environment
     * @param request
     */
    generateRequestDatabuckets(route, environment, request) {
        // do not continue if all the buckets were previously parsed
        if (!this.processedDatabuckets.some((processedDatabucket) => !processedDatabucket.parsed)) {
            return;
        }
        let databucketIdsToParse = new Set();
        // find databucket ids in environment headers
        this.findDatabucketIdsInHeaders(environment.headers).forEach((dataBucketId) => databucketIdsToParse.add(dataBucketId));
        route.responses.forEach((response) => {
            // capture databucket ids in body and relevant callback definitions
            [
                ...this.findDatabucketIdsInHeaders(response.headers),
                ...this.extractDatabucketIdsFromString(response.body),
                ...this.extractDatabucketIdsFromString(response.filePath),
                ...this.findDatabucketIdsInCallbacks(response, environment),
                ...this.findDatabucketIdsInRules(response)
            ].forEach((dataBucketId) => databucketIdsToParse.add(dataBucketId));
            if (response.databucketID) {
                databucketIdsToParse.add(response.databucketID);
            }
        });
        // capture databucket ids in found databuckets to allow for nested databucket parsing
        let nestedDatabucketIds = [];
        environment.data.forEach((databucket) => {
            if (databucketIdsToParse.has(databucket.id) ||
                [...databucketIdsToParse.keys()].some((id) => databucket.name.toLowerCase().includes(id.toLowerCase()))) {
                nestedDatabucketIds = [
                    ...this.extractDatabucketIdsFromString(databucket.value)
                ];
            }
        });
        // add nested databucket ids at the beginning of the set to ensure they are parsed first
        databucketIdsToParse = new Set([
            ...nestedDatabucketIds,
            ...databucketIdsToParse
        ]);
        if (databucketIdsToParse.size > 0) {
            let targetDatabucket;
            for (const databucketIdToParse of databucketIdsToParse) {
                targetDatabucket = this.processedDatabuckets.find((databucket) => databucket.id === databucketIdToParse ||
                    databucket.name
                        .toLowerCase()
                        .includes(databucketIdToParse.toLowerCase()));
                if (targetDatabucket && !(targetDatabucket === null || targetDatabucket === void 0 ? void 0 : targetDatabucket.parsed)) {
                    let content = targetDatabucket.value;
                    try {
                        content = (0, template_parser_1.TemplateParser)({
                            shouldOmitDataHelper: false,
                            content: targetDatabucket.value,
                            environment,
                            processedDatabuckets: this.processedDatabuckets,
                            globalVariables: this.globalVariables,
                            request: (0, requests_1.fromExpressRequest)(request),
                            envVarsPrefix: this.options.envVarsPrefix,
                            publicBaseUrl: this.options.publicBaseUrl
                        });
                        const JSONParsedcontent = JSON.parse(content);
                        targetDatabucket.value = JSONParsedcontent;
                        targetDatabucket.parsed = true;
                        targetDatabucket.validJson = true;
                    }
                    catch (error) {
                        if (error instanceof SyntaxError) {
                            targetDatabucket.value = content;
                        }
                        else {
                            targetDatabucket.value = error.message;
                        }
                        targetDatabucket.parsed = true;
                        targetDatabucket.validJson = false;
                    }
                }
            }
            this.emitProcessedDatabuckets();
        }
    }
    /**
     * Emit an event with the processed databuckets.
     * Remove the value from the processed databuckets to avoid sending
     * too much data to the client.
     */
    emitProcessedDatabuckets() {
        this.emit('data-bucket-processed', 
        // remove the value from the processed databuckets to avoid sending it to the client
        this.processedDatabuckets.map((_a) => {
            var { value: _value } = _a, props = tslib_1.__rest(_a, ["value"]);
            return (Object.assign({}, props));
        }));
    }
    /**
     * Set response properties from the locals object.
     * Currently supports the statusCode that can be set using templating helper.
     *
     * @param response
     */
    applyResponseLocals(response) {
        if (response.locals.statusCode !== undefined &&
            (0, utils_1.isValidStatusCode)(response.locals.statusCode)) {
            response.status(response.locals.statusCode);
        }
    }
    /**
     * Parse file paths and prevent path traversal
     *
     * If the path is absolute, it must stay within its original static base
     * (before the first {{...}})
     * If the path is relative, it must stay within the environment base directory
     *
     * @param filePath
     * @param request
     * @returns
     */
    getSafeFilePath(filePath, request) {
        const resolvePath = (path) => {
            const isPathAbsolute = (0, path_1.isAbsolute)(path);
            return isPathAbsolute
                ? (0, path_1.resolve)(path)
                : (0, path_1.resolve)(this.options.environmentDirectory, path);
        };
        // Convert backslashes to forward slashes (Windows compatibility)
        const rawFilePath = filePath.replace(/\\(?!\.)/g, '/');
        // Check if there is any templating helper in the file path
        const hasTemplatingHelper = /{{2,3}[^}]+}{2,3}/.test(rawFilePath);
        if (!hasTemplatingHelper) {
            // If no templating helper, allow unrestricted access
            return resolvePath(rawFilePath);
        }
        // Extract static base from templated string (before first {{...}})
        const staticBaseMatch = rawFilePath.match(/^([^{}]+)/);
        const staticBaseDir = staticBaseMatch ? (0, path_1.resolve)(staticBaseMatch[1]) : null;
        const parsedFilePath = (0, template_parser_1.TemplateParser)({
            shouldOmitDataHelper: false,
            content: rawFilePath,
            environment: this.environment,
            processedDatabuckets: this.processedDatabuckets,
            globalVariables: this.globalVariables,
            request,
            envVarsPrefix: this.options.envVarsPrefix,
            publicBaseUrl: this.options.publicBaseUrl
        });
        // Determine if the path is absolute or relative
        const isPathAbsolute = (0, path_1.isAbsolute)(parsedFilePath);
        const resolvedPath = resolvePath(parsedFilePath);
        if (isPathAbsolute) {
            // Absolute paths must stay within their original static base
            if (!staticBaseDir || !resolvedPath.startsWith(staticBaseDir)) {
                throw new Error(`Access to absolute path outside of the original static base directory (${resolvedPath})`);
            }
        }
        else {
            // Relative paths must stay within the environment base directory
            if (!resolvedPath.startsWith(this.options.environmentDirectory)) {
                throw new Error(`Access to relative path outside of the environment base directory (${resolvedPath})`);
            }
        }
        return resolvedPath;
    }
}
exports.MockoonServer = MockoonServer;
//# sourceMappingURL=server.js.map