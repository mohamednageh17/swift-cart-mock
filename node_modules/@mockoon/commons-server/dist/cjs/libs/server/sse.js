"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sse = void 0;
const node_events_1 = require("node:events");
class Sse {
    constructor(options = {
        keepAlive: true,
        keepAliveDelay: 60000
    }) {
        this.options = options;
        this.eventEmitter = new node_events_1.EventEmitter();
        this.activeListenerCount = 0;
        this.requestListener = (request, response) => {
            request.socket.setTimeout(0);
            request.socket.setNoDelay(true);
            request.socket.setKeepAlive(true);
            response.writeHead(200, {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                Connection: 'keep-alive',
                'X-Accel-Buffering': 'no'
            });
            response.flushHeaders();
            const listener = (data) => {
                response.write(`data: ${JSON.stringify(data)}\n\n`);
                response.flushHeaders();
            };
            this.eventEmitter.on('message', listener);
            this.activeListenerCount++;
            // get and send initial messages
            if (this.options.getInitialEvents) {
                const initialMessages = this.options.getInitialEvents(request);
                initialMessages.forEach((data) => {
                    this.eventEmitter.emit('message', data);
                });
            }
            if (this.options.keepAlive) {
                const keepAliveInterval = setInterval(() => {
                    response.write(':\n\n');
                }, this.options.keepAliveDelay);
                response.once('close', () => {
                    clearInterval(keepAliveInterval);
                });
            }
            response.once('close', () => {
                response.end();
                this.eventEmitter.off('message', listener);
                this.activeListenerCount--;
            });
        };
        this.options = Object.assign({
            keepAlive: true,
            keepAliveDelay: 60000
        }, options);
        this.eventEmitter.setMaxListeners(30);
    }
    send(data) {
        if (this.activeListenerCount > 0) {
            this.eventEmitter.emit('message', data);
        }
    }
    close() {
        this.eventEmitter.removeAllListeners('message');
    }
}
exports.Sse = Sse;
//# sourceMappingURL=sse.js.map