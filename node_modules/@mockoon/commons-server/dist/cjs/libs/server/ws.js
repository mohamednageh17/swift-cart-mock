"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveFileContentInWs = exports.isWebSocketOpen = exports.messageToString = exports.BroadcastContext = exports.WsRunningInstance = exports.getSafeStreamingInterval = exports.SMALLEST_POSSIBLE_STREAMING_INTERVAL = void 0;
const commons_1 = require("@mockoon/commons");
const fs_1 = require("fs");
const ws_1 = require("ws");
const response_rules_interpreter_1 = require("../response-rules-interpreter");
exports.SMALLEST_POSSIBLE_STREAMING_INTERVAL = 10;
/**
 * Returns a safe streaming interval for one-to-one and broadcast websockets.
 * Having a small interval could make server potentially unusable.
 */
const getSafeStreamingInterval = (givenInterval) => Math.max(exports.SMALLEST_POSSIBLE_STREAMING_INTERVAL, givenInterval);
exports.getSafeStreamingInterval = getSafeStreamingInterval;
/**
 * Represents a single running streaming data for a route.
 * For all socket clients, there will be only one single instance.
 */
class WsRunningInstance {
    constructor(route, serverContext, serverRequest, handler) {
        this.route = route;
        this.serverContext = serverContext;
        this.serverRequest = serverRequest;
        this.handler = handler;
        this.isRunning = false;
    }
    get running() {
        return this.isRunning;
    }
    run() {
        let responseNumber = 1;
        this.closeable = setInterval(() => {
            const enabledRouteResponse = new response_rules_interpreter_1.ResponseRulesInterpreter(this.route.responses, this.serverRequest, this.route.responseMode, this.serverContext.environment, this.serverContext.processedDatabuckets, this.serverContext.globalVariables, this.serverContext.envVarPrefix, this.serverContext.publicBaseUrl).chooseResponse(responseNumber);
            if (!enabledRouteResponse) {
                return;
            }
            responseNumber += 1;
            this.handler(responseNumber, enabledRouteResponse);
        }, (0, exports.getSafeStreamingInterval)(this.route.streamingInterval));
        this.isRunning = true;
    }
    close() {
        if (this.closeable) {
            clearInterval(this.closeable);
            this.isRunning = false;
        }
    }
}
exports.WsRunningInstance = WsRunningInstance;
/**
 * Context for all websocket broadcast end points.
 * This class holds all streaming data generators per route.
 * This guarantees that it creates one and only generator for a given route.
 */
class BroadcastContext {
    constructor() {
        this.routeDataGenerators = new Map();
    }
    get runningInstances() {
        return new Set(this.routeDataGenerators.keys());
    }
    static getInstance() {
        if (!BroadcastContext.context) {
            BroadcastContext.context = new BroadcastContext();
        }
        return BroadcastContext.context;
    }
    registerRoute(route, serverContext, serverRequest, nextResponseHandler) {
        const ref = this.routeDataGenerators.get(route.endpoint);
        if (ref) {
            // A reference already exists. So, broadcasting will be done by it.
            // No need to create another.
            return false;
        }
        const instance = new WsRunningInstance(route, serverContext, serverRequest, nextResponseHandler);
        this.routeDataGenerators.set(route.endpoint, instance);
        instance.run();
        return true;
    }
    /**
     * This will close all running contexts.
     */
    closeAll() {
        this.routeDataGenerators.forEach((runner) => {
            runner.close();
        });
        this.routeDataGenerators.clear();
    }
    closeRoute(route) {
        const ref = this.routeDataGenerators.get(route.endpoint);
        if (ref) {
            this.routeDataGenerators.delete(route.endpoint);
            ref.close();
        }
    }
}
exports.BroadcastContext = BroadcastContext;
/**
 * Convert incoming websocket message to string representation.
 *
 * @param message
 */
const messageToString = (message) => {
    if (!message) {
        return '';
    }
    if (Array.isArray(message)) {
        return Buffer.concat(message).toString('utf8');
    }
    return message.toString('utf8');
};
exports.messageToString = messageToString;
/**
 * Returns true if the given socket client is still in open state.
 *
 * @param socket
 */
const isWebSocketOpen = (socket) => socket.readyState === ws_1.WebSocket.OPEN;
exports.isWebSocketOpen = isWebSocketOpen;
/**
 * Serve the content of the file as a response.
 * Will use templating if specified to do so.
 *
 * @param socket
 * @param route
 * @param routeResponse
 * @param eventEmitter
 * @param filePath
 * @param templateParser
 */
const serveFileContentInWs = (socket, route, routeResponse, eventEmitter, filePath, templateParser) => {
    (0, fs_1.readFile)(filePath, (err, fileData) => {
        if (err) {
            eventEmitter.emit('error', commons_1.ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, err, {
                routePath: route.endpoint,
                routeUUID: route.uuid
            });
            // we close the socket if the provided file cannot be read.
            socket.send(`Status: 500, File reading error! (${err.message})`, () => {
                socket.close();
            });
        }
        else {
            let fileContent = fileData.toString();
            if (!routeResponse.disableTemplating) {
                fileContent = templateParser(fileContent);
            }
            socket.send(fileContent);
        }
    });
};
exports.serveFileContentInWs = serveFileContentInWs;
//# sourceMappingURL=ws.js.map