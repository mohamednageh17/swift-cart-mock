"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataHelpers = void 0;
const handlebars_1 = require("handlebars");
const object_path_1 = require("object-path");
const utils_1 = require("../utils");
const getDataBucket = function (processedDatabuckets, dataBucketName) {
    return processedDatabuckets.find((databucket) => databucket.id === dataBucketName ||
        databucket.name.toLowerCase().includes(dataBucketName.toLowerCase()));
};
const DataHelpers = function (processedDatabuckets) {
    return {
        data: function (...args) {
            const parameters = args.slice(0, -1);
            // at least the databucket name/id is required
            if (parameters.length < 1) {
                return;
            }
            const targetDatabucket = getDataBucket(processedDatabuckets, (0, utils_1.fromSafeString)(parameters[0]));
            if (targetDatabucket === undefined) {
                return;
            }
            const value = (0, utils_1.getValueFromPath)(targetDatabucket.value, (0, utils_1.fromSafeString)(parameters[1]), '');
            if (Array.isArray(value) || typeof value === 'object') {
                return new handlebars_1.SafeString(JSON.stringify(value));
            }
            else {
                return new handlebars_1.SafeString(value);
            }
        },
        dataRaw: function (...args) {
            const parameters = args.slice(0, -1);
            // at least the databucket name/id is required
            if (parameters.length < 1) {
                return;
            }
            const targetDatabucket = getDataBucket(processedDatabuckets, (0, utils_1.fromSafeString)(parameters[0]));
            if (targetDatabucket === undefined) {
                return;
            }
            return (0, utils_1.getValueFromPath)(targetDatabucket.value, (0, utils_1.fromSafeString)(parameters[1]), '');
        },
        /**
         * Update a databucket value
         *
         * Expect the following parameters:
         * - operator, default is 'set', can be 'push', 'del', 'inc', 'dec', 'invert'
         * - databucket name/id
         * - path to the value to update, keep empty or null to replace the whole databucket value
         * - value to set
         * @param args
         * @returns
         */
        setData: function (...args) {
            var _a;
            const parameters = args.slice(0, -1);
            // at least the operator, databucket name/id, path and values can be omitted, especially for del and invert
            if (parameters.length < 2) {
                return;
            }
            const operators = ['push', 'del', 'inc', 'dec', 'invert', 'set', 'merge'];
            let operator = String((0, utils_1.fromSafeString)(parameters[0]));
            // default operator is 'set'
            if (!operators.includes(operator)) {
                operator = 'set';
            }
            const targetDatabucket = getDataBucket(processedDatabuckets, (0, utils_1.fromSafeString)(parameters[1]));
            if (targetDatabucket === undefined) {
                return;
            }
            const path = (0, utils_1.convertPathToArray)(String((_a = (0, utils_1.fromSafeString)(parameters[2])) !== null && _a !== void 0 ? _a : ''));
            // new value can be of any type
            const newValue = (0, utils_1.fromSafeString)(parameters[3]);
            if (operator === 'set') {
                if (path) {
                    (0, object_path_1.set)(targetDatabucket.value, path, newValue);
                }
                else {
                    targetDatabucket.value = newValue;
                }
            }
            else if (operator === 'merge') {
                const currentValue = path
                    ? (0, object_path_1.get)(targetDatabucket.value, path)
                    : targetDatabucket.value;
                if (typeof currentValue === 'object' &&
                    !Array.isArray(currentValue) &&
                    currentValue !== null &&
                    typeof newValue === 'object' &&
                    !Array.isArray(newValue) &&
                    newValue !== null) {
                    if (path) {
                        (0, object_path_1.set)(targetDatabucket.value, path, Object.assign(Object.assign({}, currentValue), newValue));
                    }
                    else {
                        targetDatabucket.value = Object.assign(Object.assign({}, currentValue), newValue);
                    }
                }
                else {
                    if (path) {
                        (0, object_path_1.set)(targetDatabucket.value, path, newValue);
                    }
                    else {
                        targetDatabucket.value = newValue;
                    }
                }
            }
            else if (operator === 'push') {
                if (path && Array.isArray((0, object_path_1.get)(targetDatabucket.value, path))) {
                    (0, object_path_1.push)(targetDatabucket.value, path, newValue);
                }
                else if (!path && Array.isArray(targetDatabucket.value)) {
                    targetDatabucket.value.push(newValue);
                }
            }
            else if (operator === 'del') {
                if (path) {
                    (0, object_path_1.del)(targetDatabucket.value, path);
                }
                else {
                    targetDatabucket.value = undefined;
                }
            }
            else if ((operator === 'inc' || operator === 'dec') &&
                (!newValue || !isNaN(Number(newValue)))) {
                const newValueNum = Number(newValue);
                if (path && !isNaN(Number((0, object_path_1.get)(targetDatabucket.value, path)))) {
                    (0, object_path_1.set)(targetDatabucket.value, path, Number((0, object_path_1.get)(targetDatabucket.value, path)) +
                        (newValueNum ? newValueNum : 1) * (operator === 'inc' ? 1 : -1));
                }
                else if (!path && !isNaN(Number(targetDatabucket.value))) {
                    targetDatabucket.value =
                        Number(targetDatabucket.value) +
                            (newValueNum ? newValueNum : 1) * (operator === 'inc' ? 1 : -1);
                }
            }
            else if (operator === 'invert') {
                if (path &&
                    typeof (0, object_path_1.get)(targetDatabucket.value, path) === 'boolean') {
                    (0, object_path_1.set)(targetDatabucket.value, path, !(0, object_path_1.get)(targetDatabucket.value, path));
                }
                else if (!path && typeof targetDatabucket.value === 'boolean') {
                    targetDatabucket.value = !targetDatabucket.value;
                }
            }
        }
    };
};
exports.DataHelpers = DataHelpers;
//# sourceMappingURL=data-helpers.js.map