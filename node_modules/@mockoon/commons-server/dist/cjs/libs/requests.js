"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromServerRequest = exports.fromWsRequest = exports.fromExpressRequest = void 0;
const path_to_regexp_1 = require("path-to-regexp");
const commons_1 = require("@mockoon/commons");
const url_1 = require("url");
const utils_1 = require("./utils");
const toString = (data) => {
    if (typeof data === 'string') {
        return data;
    }
    else if (typeof data === 'object') {
        return JSON.stringify(data);
    }
    else if (typeof data === 'undefined') {
        return undefined;
    }
    return data + '';
};
const parseCookies = (req) => {
    var _a;
    const obj = {};
    const cookieHeader = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.cookie;
    if (!cookieHeader) {
        return obj;
    }
    cookieHeader.split(';').forEach((cookie) => {
        const [name, ...rest] = cookie.split('=');
        if (!name) {
            return;
        }
        const value = rest.join('=').trim();
        if (!value) {
            // skip pairs with empty values
            return;
        }
        obj[name.trim()] = decodeURIComponent(value);
    });
    return obj;
};
/**
 * Creates a common ServerRequest instance from Express request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req Express request object
 * @returns Mockoon common server request
 */
const fromExpressRequest = (req) => {
    var _a, _b;
    return ({
        body: req.body,
        cookies: req.cookies,
        header: (name) => { var _a; return (_a = req.header) === null || _a === void 0 ? void 0 : _a.call(req, name); },
        headers: req.headers,
        get: (headerName) => { var _a; return (_a = req.header) === null || _a === void 0 ? void 0 : _a.call(req, headerName); },
        hostname: req.hostname,
        ip: req.ip,
        method: req.method,
        params: req.params,
        // store the original path of the request, e.g. /api/v1/users/:id
        originalPath: (_b = (_a = req.route) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '',
        originalRequest: req,
        query: req.query,
        stringBody: req.stringBody || ''
    });
};
exports.fromExpressRequest = fromExpressRequest;
/**
 * Creates a common ServerRequest instance from Web socket request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req websocket connection request
 * @param message message received from websocket now
 */
const fromWsRequest = (req, originalRoute, message) => {
    var _a, _b, _c;
    const location = (0, url_1.parse)(req.url || '', true);
    let pathParams = {};
    const urlPathMatchFn = (0, path_to_regexp_1.match)(originalRoute.endpoint.startsWith('/')
        ? originalRoute.endpoint
        : '/' + originalRoute.endpoint);
    const result = urlPathMatchFn(location.pathname || '');
    if (result) {
        pathParams = result.params || {};
    }
    const structuredMessage = message
        ? (0, utils_1.parseWebSocketMessage)(message || '', req)
        : undefined;
    return {
        body: structuredMessage || req.body,
        cookies: parseCookies(req),
        headers: req.headers,
        header: (name) => { var _a; return (_a = req.headers) === null || _a === void 0 ? void 0 : _a[name]; },
        get: (headerName) => { var _a; return (_a = req.headers) === null || _a === void 0 ? void 0 : _a[headerName]; },
        hostname: (_a = req.headers) === null || _a === void 0 ? void 0 : _a['host'],
        ip: ((_b = req.headers) === null || _b === void 0 ? void 0 : _b['x-forwarded-for']) || ((_c = req.socket) === null || _c === void 0 ? void 0 : _c.remoteAddress),
        method: req.method,
        originalPath: `${originalRoute.endpoint.startsWith('/') ? '' : '/'}${originalRoute.endpoint}`,
        originalRequest: req,
        params: (0, commons_1.CloneObject)(pathParams),
        query: (0, commons_1.CloneObject)(location.query),
        stringBody: message || toString(req.body) || ''
    };
};
exports.fromWsRequest = fromWsRequest;
/**
 * Copies the given request with a new message.
 *
 * This method is useful to mimic the behaviour of websockets, because,
 * we need to keep the access of original connection request and then subsequent messages
 * in a full-duplex communication. This will update the body content with the received
 * message, so that helper classes will use that instead of original body.
 *
 * @param req
 * @param message received web socket message.
 * @returns
 */
const fromServerRequest = (req, message) => {
    const structuredMessage = message
        ? (0, utils_1.parseRequestMessage)(message || '', req)
        : undefined;
    return {
        body: structuredMessage || req.body,
        cookies: req.cookies,
        headers: req.headers,
        header: req.header,
        get: req.get,
        hostname: req.hostname,
        ip: req.ip,
        method: req.method,
        originalPath: req.originalPath,
        originalRequest: req.originalRequest,
        params: req.params,
        query: req.query,
        stringBody: message || req.stringBody || ''
    };
};
exports.fromServerRequest = fromServerRequest;
//# sourceMappingURL=requests.js.map