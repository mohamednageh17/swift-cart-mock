import { Request } from 'express';
import { Route } from '@mockoon/commons';
/**
 * A generic interface covering different types of requests.
 * Such as, http, ws, graphql, etc.
 */
export interface ServerRequest {
    cookies: any;
    headers: Record<string, string | string[] | undefined>;
    header: (name: string) => string | string[] | undefined;
    get: (headerName: string) => string | string[] | undefined;
    params: any;
    query: any;
    body: any;
    stringBody: string;
    hostname: string | undefined;
    ip: string | undefined;
    method: string | undefined;
    originalPath: string;
    originalRequest: any;
}
/**
 * Creates a common ServerRequest instance from Express request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req Express request object
 * @returns Mockoon common server request
 */
export declare const fromExpressRequest: (req: Request) => ServerRequest;
/**
 * Creates a common ServerRequest instance from Web socket request.
 * To pass into helper classes, this common server request is required.
 *
 * @param req websocket connection request
 * @param message message received from websocket now
 */
export declare const fromWsRequest: (req: Request, originalRoute: Route, message?: string) => ServerRequest;
/**
 * Copies the given request with a new message.
 *
 * This method is useful to mimic the behaviour of websockets, because,
 * we need to keep the access of original connection request and then subsequent messages
 * in a full-duplex communication. This will update the body content with the received
 * message, so that helper classes will use that instead of original body.
 *
 * @param req
 * @param message received web socket message.
 * @returns
 */
export declare const fromServerRequest: (req: ServerRequest, message?: string) => ServerRequest;
