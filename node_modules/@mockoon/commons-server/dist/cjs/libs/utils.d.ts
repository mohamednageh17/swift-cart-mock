import { Callback, Header, InFlightRequest, InvokedCallback, Methods, Route, Transaction } from '@mockoon/commons';
import { Request, Response } from 'express';
import { SafeString } from 'handlebars';
import { IncomingMessage } from 'http';
import { ServerRequest } from './requests';
export { lookup as mimeTypeLookup } from 'mime-types';
export { get as objectGetPath } from 'object-path';
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
export declare const IsEmpty: (obj: any) => boolean;
/**
 * Decompress body based on content-encoding
 *
 * Zstd support requires Node.js 22 or higher, thus it is conditionally applied
 *
 * @param response
 */
export declare const DecompressBody: (response: Response) => any;
/**
 * Returns true if given HTTP method is a body supporting one. Otherwise false.
 * @param method
 */
export declare function isBodySupportingMethod(method: Methods): boolean;
/**
 * Creates a callback invocation record which has information
 * about the invoked details.
 * @param callback
 * @param url
 * @param requestBody
 * @param requestHeaders
 * @param fetchResponse
 * @param responseBody
 */
export declare function CreateCallbackInvocation(callback: Callback, url: string, requestBody: string | null | undefined, requestHeaders: Header[], fetchResponse: globalThis.Response, responseBody: any): InvokedCallback;
/**
 * Creates in-flight request object.
 *
 * @param requestId
 * @param request
 * @param route
 */
export declare function CreateInFlightRequest(requestId: string, request: IncomingMessage, route: Route): InFlightRequest;
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
export declare function CreateTransaction(request: Request, response: Response): Transaction;
/**
 * Convert a string to base64
 *
 * @param text
 */
export declare const ToBase64: (text: string) => string;
/**
 * Convert base64 to a string
 *
 * @param base64
 */
export declare const FromBase64: (base64: string) => string;
/**
 * Extract the string value from a SafeString
 *
 * @param value
 * @returns
 */
export declare const fromSafeString: (value: any | SafeString) => any;
/**
 * Parse a number from a SafeString if needed.
 *
 * @param text
 * @returns
 */
export declare const numberFromSafeString: (text: string | SafeString) => number;
/**
 *
 * @param text
 * @returns object | null
 */
export declare const objectFromSafeString: (text: string | SafeString) => any;
/**
 * Resolve a file path relatively to the current environment folder if provided
 */
export declare const resolvePathFromEnvironment: (filePath: string, environmentDirectory?: string) => string;
/**
 * Convert an object path (for the object-path lib) containing escaped dots '\.'
 * to an array of strings to allow fetching properties containing dots.
 *
 * Example:
 * 'get.a.property\.with\.dots => ['get', 'a', 'property.with.dots']
 *
 * To query an object like this:
 *
 * ```
 * {
 *   get: {
 *     a: {
 *       'property.with.dots': "value"
 *     }
 *   }
 * }
 * ```
 * @param str
 */
export declare const convertPathToArray: (str: string) => string | string[];
/**
 * Prepare a path for express: add a leading slash, deduplicate slashes and replace spaces with %20
 *
 * @param endpointPrefix
 * @param endpoint
 * @returns
 */
export declare const preparePath: (endpointPrefix: string, endpoint: string) => string;
/**
 * Escape special characters in a string to be used in a regex
 * Taken from Lodash escapeRegExp
 *
 * @param text
 * @returns
 */
export declare const escapeRegExp: (text: string) => string;
/**
 * Perform a full text search on an object. The object can be any valid JSON type
 *
 * @param object
 * @param query
 * @returns
 */
export declare const fullTextSearch: (object: unknown, query: string) => boolean;
/**
 * Validates a given JSONPath string to check if the filter expressions are safe for evaluation.
 * If no filter expression is found in the path, it returns the path as valid.
 * If filter expressions are found, each one is checked against a regular expression to ensure it is safe.
 * The function returns a boolean indicating whether the path is valid.
 *
 * If path is too long, it is considered unsafe due to the time complexity of the hasFilter check.
 *
 * @param {string} path - The JSONPath string to be validated.
 * @returns {boolean} - whether JSONPath string is safe or not
 */
export declare const isSafeJSONPath: (path: string) => boolean;
/**
 * Look for a value in an object or array using a path (dot notation or JSONPath).
 * If no path is provided, return the full data.
 * If the value is not found, return the default value.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
export declare const getValueFromPath: {
    (data: any, path: string, defaultValue: any): any;
    jmesPath(data: any, path: string, defaultValue: any): any;
    jsonPath(data: any, path: string, defaultValue: any): any;
    objectPath(data: any, path: string, defaultValue: any): any;
};
/**
 * Parses a websocket message based on the content-type specified in the socket connection.
 * We have to use this function, because this has to be called when creating a Mockoon
 * ServerRequest object from a WS connection request.
 *
 * @param messageData
 * @param request
 */
export declare const parseWebSocketMessage: (messageData: string, request?: IncomingMessage) => any;
/**
 * Returns appropriate object by parsing it as necessary.
 * This will check content-type header and will parse messageData based on the type.
 *
 * @param data
 * @param request
 */
export declare const parseRequestMessage: (data: string, request?: ServerRequest) => any;
/**
 * Validate status code (100-999)
 *
 * @param statusCode - The status code to validate
 * @returns boolean
 */
export declare const isValidStatusCode: (statusCode: number) => boolean;
