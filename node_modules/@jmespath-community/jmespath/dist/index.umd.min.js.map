{"version":3,"sources":["../src/utils/index.ts","../src/utils/strings.ts","../src/Lexer.ts","../src/Parser.ts","../src/utils/text.ts","../src/Runtime.ts","../src/Scope.ts","../src/TreeInterpreter.ts","../src/index.ts"],"names":["isObject","obj","strictDeepEqual","first","second","i","firstEntries","secondKeys","key","value","isFalse","isAlpha","ch","isNum","isAlphaNum","ensureInteger","ensurePositiveInteger","ensureNumbers","operands","notZero","n","add","left","right","sub","mul","divide","div","mod","findFirst","subject","start","end","offset","findLast","lower","ensurePadFuncParams","name","width","padding","padLeft","padRight","replace","string","by","count","split","search","trim","chars","trimLeft","trimRight","trimImpl","list","regExper","pattern","upper","basicTokens","operatorStartToken","skipChars","StreamLexer","__publicField","stream","options","tokens","identifier","token","literal","error","maxLength","current","ok","peek","orElse","literalString","startingChars","jsonLiterals","numberLooking","_","text","Lexer","Lexer_default","bindingPower","TokenParser","_TokenParser","expression","ast","rbp","leftToken","currentTokenType","child","tokenName","trueExpr","falseExpr","args","condition","leftNode","keyword","tokenType","message","indexExpr","parts","index","part","next","stop","step","separated","binding","isEndToken","matchEndToken","comparator","operator","lookahead","expressions","pairs","identifierTypes","keyToken","keyName","Parser","Parser_default","Text","_Text","other","leftCp","rightCp","s","createMathFunction","mathFn","createStringFunction","stringFn","createObjectFunction","objFn","Runtime","interpreter","inputArray","sum","searchable","searchValue","resolvedArgs","searchStr","suffix","array","pair","exprefNode","keyFunction","acc","cur","k","inputValue","joinChar","listJoin","elements","mapped","maxElement","resolvedArray","maxNumber","maxRecord","merged","minElement","minNumber","minRecord","reversedArray","sortedArray","requiredType","throwInvalidTypeError","rt","item","a","b","exprA","exprB","x","y","typeName","convertedValue","length","arr","customFunction","signature","result","override","warn","exists","functionEntry","numberOfRequiredArgs","argSignature","lastArgIsVariadic","tooFewArgs","tooManyArgs","tooFewModifier","pluralized","currentSpec","actualType","expectedType","expected","typeId","actual","argValue","subtype","allowedTypes","msg","t","findFn","padFn","trimFn","ScopeChain","_ScopeChain","data","outer","emptyScopeChain","TreeInterpreter","_TreeInterpreter","scope","node","bindings","reference","variable","allowString","base","collected","elem","values","results","matched","operand","original","arrayLength","sliceNode","actualValue","nextActualValue","collection","TreeInterpreterInstance","TreeInterpreter_default","TYPE_ANY","TYPE_ARRAY","TYPE_ARRAY_ARRAY","TYPE_ARRAY_NUMBER","TYPE_ARRAY_OBJECT","TYPE_ARRAY_STRING","TYPE_BOOLEAN","TYPE_EXPREF","TYPE_NULL","TYPE_NUMBER","TYPE_OBJECT","TYPE_STRING","compile","tokenize","registerFunction","functionName","register","unregisterFunction","isRegistered","getRegisteredFunctions","getCustomFunctions","clearCustomFunctions","nodeTree","Scope","jmespath"],"mappings":"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","file":"index.umd.min.js","sourcesContent":["import { JSONValue } from '../JSON.type';\n\nexport const isObject = (obj: unknown): obj is Record<string, unknown> => {\n  return obj !== null && Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nexport const strictDeepEqual = (first: unknown, second: unknown): boolean => {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first !== typeof second) {\n    return false;\n  }\n  if (Array.isArray(first) && Array.isArray(second)) {\n    if (first.length !== second.length) {\n      return false;\n    }\n    for (let i = 0; i < first.length; i += 1) {\n      if (!strictDeepEqual(first[i], second[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (isObject(first) && isObject(second)) {\n    const firstEntries = Object.entries(first);\n    const secondKeys = new Set(Object.keys(second));\n    if (firstEntries.length !== secondKeys.size) {\n      return false;\n    }\n    for (const [key, value] of firstEntries) {\n      if (!strictDeepEqual(value, second[key])) {\n        return false;\n      }\n      secondKeys.delete(key);\n    }\n    return secondKeys.size === 0;\n  }\n  return false;\n};\n\nexport const isFalse = (obj: unknown): boolean => {\n  // falsey values\n  if (obj === null || obj === undefined || obj === false) {\n    return true;\n  }\n  if (typeof obj === 'string') {\n    return obj === '';\n  }\n  if (typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.length === 0;\n    }\n    if (obj === null) {\n      return true;\n    }\n    // check if object is empty\n    return Object.keys(obj).length === 0;\n  }\n  return false;\n};\n\nexport const isAlpha = (ch: string): boolean => {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_';\n};\n\nexport const isNum = (ch: string): boolean => {\n  return (ch >= '0' && ch <= '9') || ch === '-';\n};\nexport const isAlphaNum = (ch: string): boolean => {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch === '_';\n};\n\nexport const ensureInteger = (value: unknown): number => {\n  if (!(typeof value === 'number') || Math.floor(value) !== value) {\n    throw new Error('invalid-value: expecting an integer.');\n  }\n  return <number>value;\n};\nexport const ensurePositiveInteger = (value: unknown): number => {\n  if (!(typeof value === 'number') || <number>value < 0 || Math.floor(value) !== value) {\n    throw new Error('invalid-value: expecting a non-negative integer.');\n  }\n  return <number>value;\n};\n\nexport const ensureNumbers = (...operands: (JSONValue | undefined)[]): void => {\n  for (let i = 0; i < operands.length; i++) {\n    if (operands[i] === null || operands[i] === undefined) {\n      throw new Error('not-a-number: undefined');\n    }\n    if (typeof operands[i] !== 'number') {\n      throw new Error('not-a-number');\n    }\n  }\n};\n\nconst notZero = (n: number): number => {\n  n = +n; // coerce to number\n  if (!n) {\n    // matches -0, +0, NaN\n    throw new Error('not-a-number: divide by zero');\n  }\n  return n;\n};\n\nexport const add = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = (left as number) + (right as number);\n  return result;\n};\nexport const sub = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = (left as number) - (right as number);\n  return result;\n};\nexport const mul = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = (left as number) * (right as number);\n  return result;\n};\nexport const divide = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = (left as number) / notZero(right as number);\n  return result;\n};\nexport const div = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = Math.floor((left as number) / notZero(right as number));\n  return result;\n};\nexport const mod = (left?: JSONValue, right?: JSONValue): number => {\n  ensureNumbers(left, right);\n  const result = (left as number) % (right as number);\n  return result;\n};\n","import { ensureInteger, ensurePositiveInteger } from '.';\n\nexport const findFirst = (subject: string, sub: string, start?: number, end?: number): number | null => {\n  if (!subject || !sub) {\n    return null;\n  }\n  start = Math.max(ensureInteger((start = start || 0)), 0);\n  end = Math.min(ensureInteger((end = end || subject.length)), subject.length);\n  const offset = subject.slice(start, end).indexOf(sub);\n  return offset === -1 ? null : offset + start;\n};\nexport const findLast = (subject: string, sub: string, start?: number, end?: number): number | null => {\n  if (!subject || !sub) {\n    return null;\n  }\n  start = Math.max(ensureInteger((start = start || 0)), 0);\n  end = Math.min(ensureInteger((end = end || subject.length)), subject.length);\n  const offset = subject.slice(start, end).lastIndexOf(sub);\n  const result = offset === -1 ? null : offset + start;\n  return result;\n};\nexport const lower = (subject: string): string => subject.toLowerCase();\nconst ensurePadFuncParams = (name: string, width: number, padding?: string): string => {\n  padding = padding || ' ';\n  if (padding.length > 1) {\n    throw new Error(`invalid value, ${name} expects its 'pad' parameter to be a valid string with a single codepoint`);\n  }\n  ensurePositiveInteger(width);\n  return padding;\n};\nexport const padLeft = (subject: string, width: number, padding?: string): string => {\n  padding = ensurePadFuncParams('pad_left', width, padding);\n  return (subject && subject.padStart(width, padding)) || '';\n};\nexport const padRight = (subject: string, width: number, padding?: string): string => {\n  padding = ensurePadFuncParams('pad_right', width, padding);\n  return (subject && subject.padEnd(width, padding)) || '';\n};\nexport const replace = (subject: string, string: string, by: string, count?: number): string => {\n  if (count === 0) {\n    return subject;\n  }\n  if (!count) {\n    // emulating es2021: String.prototype.replaceAll()\n    return subject.split(string).join(by);\n  }\n  ensurePositiveInteger(count);\n  [...Array(count).keys()].map(() => (subject = subject.replace(string, by)));\n  return subject;\n};\nexport const split = (subject: string, search: string, count?: number): string[] => {\n  if (subject.length == 0 && search.length === 0) {\n    return [];\n  }\n  if (count === null || count === undefined) {\n    return subject.split(search);\n  }\n  ensurePositiveInteger(count);\n  if (count === 0) {\n    return [subject];\n  }\n  const split = subject.split(search);\n  return [...split.slice(0, count), split.slice(count).join(search)];\n};\nexport const trim = (subject: string, chars?: string): string => {\n  return trimLeft(trimRight(subject, chars), chars);\n};\nexport const trimLeft = (subject: string, chars?: string): string => {\n  return trimImpl(subject, list => new RegExp(`^[${list}]*(.*?)`), chars);\n};\nexport const trimRight = (subject: string, chars?: string): string => {\n  return trimImpl(subject, list => new RegExp(`(.*?)[${list}]*$`), chars);\n};\nconst trimImpl = (subject: string, regExper: (arg: string) => RegExp, chars?: string): string => {\n  const pattern = chars ? chars.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') : '\\\\s\\u0085';\n  return subject.replace(regExper(pattern), '$1');\n};\n\nexport const upper = (subject: string): string => subject.toUpperCase();\n","import { JSONValue } from './JSON.type';\nimport { LexerOptions, LexerToken, Token } from './Lexer.type';\nimport { isAlpha, isAlphaNum, isNum } from './utils/index';\nimport { replace } from './utils/strings';\n\nexport const basicTokens: Record<string, Token> = {\n  '(': Token.TOK_LPAREN,\n  ')': Token.TOK_RPAREN,\n  '*': Token.TOK_STAR,\n  ',': Token.TOK_COMMA,\n  '.': Token.TOK_DOT,\n  ':': Token.TOK_COLON,\n  '@': Token.TOK_CURRENT,\n  ']': Token.TOK_RBRACKET,\n  '{': Token.TOK_LBRACE,\n  '}': Token.TOK_RBRACE,\n  '+': Token.TOK_PLUS,\n  '%': Token.TOK_MODULO,\n  '?': Token.TOK_QUESTION,\n  '\\u2212': Token.TOK_MINUS,\n  '\\u00d7': Token.TOK_MULTIPLY,\n  '\\u00f7': Token.TOK_DIVIDE,\n};\n\nconst operatorStartToken: Record<string, boolean> = {\n  '!': true,\n  '<': true,\n  '=': true,\n  '>': true,\n  '&': true,\n  '|': true,\n  '/': true,\n};\n\nconst skipChars: Record<string, boolean> = {\n  '\\t': true,\n  '\\n': true,\n  '\\r': true,\n  ' ': true,\n};\n\nclass StreamLexer {\n  private _current = 0;\n  private _enable_legacy_literals = false;\n\n  tokenize(stream: string, options?: LexerOptions): LexerToken[] {\n    const tokens: LexerToken[] = [];\n    this._current = 0;\n    this._enable_legacy_literals = options?.enable_legacy_literals || false;\n\n    let start;\n    let identifier;\n    let token;\n    while (this._current < stream.length) {\n      if (isAlpha(stream[this._current])) {\n        start = this._current;\n        identifier = this.consumeUnquotedIdentifier(stream);\n        tokens.push({\n          start,\n          type: Token.TOK_UNQUOTEDIDENTIFIER,\n          value: identifier,\n        });\n      } else if (basicTokens[stream[this._current]] !== undefined) {\n        tokens.push({\n          start: this._current,\n          type: basicTokens[stream[this._current]],\n          value: stream[this._current],\n        });\n        this._current += 1;\n      } else if (stream[this._current] === '$') {\n        start = this._current;\n        if (this._current + 1 < stream.length && isAlpha(stream[this._current + 1])) {\n          this._current += 1;\n          identifier = this.consumeUnquotedIdentifier(stream);\n          tokens.push({\n            start,\n            type: Token.TOK_VARIABLE,\n            value: identifier,\n          });\n        } else {\n          tokens.push({\n            start: start,\n            type: Token.TOK_ROOT,\n            value: stream[this._current],\n          });\n          this._current += 1;\n        }\n      } else if (stream[this._current] === '-') {\n        if (this._current + 1 < stream.length && isNum(stream[this._current + 1])) {\n          const token = this.consumeNumber(stream);\n          token && tokens.push(token);\n        } else {\n          const token = {\n            start: this._current,\n            type: Token.TOK_MINUS,\n            value: '-',\n          };\n          tokens.push(token);\n          this._current += 1;\n        }\n      } else if (isNum(stream[this._current])) {\n        token = this.consumeNumber(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '[') {\n        token = this.consumeLBracket(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '\"') {\n        start = this._current;\n        identifier = this.consumeQuotedIdentifier(stream);\n        tokens.push({\n          start,\n          type: Token.TOK_QUOTEDIDENTIFIER,\n          value: identifier,\n        });\n      } else if (stream[this._current] === `'`) {\n        start = this._current;\n        identifier = this.consumeRawStringLiteral(stream);\n        tokens.push({\n          start,\n          type: Token.TOK_LITERAL,\n          value: identifier,\n        });\n      } else if (stream[this._current] === '`') {\n        start = this._current;\n        const literal = this.consumeLiteral(stream);\n        tokens.push({\n          start,\n          type: Token.TOK_LITERAL,\n          value: literal,\n        });\n      } else if (operatorStartToken[stream[this._current]] !== undefined) {\n        token = this.consumeOperator(stream);\n        token && tokens.push(token);\n      } else if (skipChars[stream[this._current]] !== undefined) {\n        this._current += 1;\n      } else {\n        const error = new Error(`Syntax error: unknown character: ${stream[this._current]}`);\n        error.name = 'LexerError';\n        throw error;\n      }\n    }\n    return tokens;\n  }\n\n  private consumeUnquotedIdentifier(stream: string): string {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n      this._current += 1;\n    }\n    return stream.slice(start, this._current);\n  }\n\n  private consumeQuotedIdentifier(stream: string): string {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (stream[this._current] !== '\"' && this._current < maxLength) {\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\' || stream[current + 1] === '\"')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const [value, ok] = this.parseJSON(stream.slice(start, this._current));\n    if (!ok) {\n      const error = new Error(`syntax: unexpected end of JSON input`);\n      error.name = 'LexerError';\n      throw error;\n    }\n    return <string>value;\n  }\n\n  private consumeRawStringLiteral(stream: string): string {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (stream[this._current] !== `'` && this._current < maxLength) {\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\' || stream[current + 1] === `'`)) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const literal = stream.slice(start + 1, this._current - 1);\n    return replace(replace(literal, `\\\\\\\\`, `\\\\`), `\\\\'`, `'`);\n  }\n\n  private consumeNumber(stream: string): LexerToken {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (isNum(stream[this._current]) && this._current < maxLength) {\n      this._current += 1;\n    }\n    const value = parseInt(stream.slice(start, this._current), 10);\n    return { start, value, type: Token.TOK_NUMBER };\n  }\n\n  private consumeLBracket(stream: string): LexerToken {\n    const start = this._current;\n    this._current += 1;\n    if (stream[this._current] === '?') {\n      this._current += 1;\n      return { start, type: Token.TOK_FILTER, value: '[?' };\n    }\n    if (stream[this._current] === ']') {\n      this._current += 1;\n      return { start, type: Token.TOK_FLATTEN, value: '[]' };\n    }\n    return { start, type: Token.TOK_LBRACKET, value: '[' };\n  }\n\n  private consumeOrElse(stream: string, peek: string, token: Token, orElse: Token): LexerToken {\n    const start = this._current;\n    this._current += 1;\n    if (this._current < stream.length && stream[this._current] === peek) {\n      this._current += 1;\n      return {\n        start: start,\n        type: orElse,\n        value: stream.slice(start, this._current),\n      };\n    }\n    return { start: start, type: token, value: stream[start] };\n  }\n\n  private consumeOperator(stream: string): LexerToken | void {\n    const start = this._current;\n    const startingChar = stream[start];\n    switch (startingChar) {\n      case '!':\n        return this.consumeOrElse(stream, '=', Token.TOK_NOT, Token.TOK_NE);\n      case '<':\n        return this.consumeOrElse(stream, '=', Token.TOK_LT, Token.TOK_LTE);\n      case '>':\n        return this.consumeOrElse(stream, '=', Token.TOK_GT, Token.TOK_GTE);\n      case '=':\n        return this.consumeOrElse(stream, '=', Token.TOK_ASSIGN, Token.TOK_EQ);\n      case '&':\n        return this.consumeOrElse(stream, '&', Token.TOK_EXPREF, Token.TOK_AND);\n      case '|':\n        return this.consumeOrElse(stream, '|', Token.TOK_PIPE, Token.TOK_OR);\n      case '/':\n        return this.consumeOrElse(stream, '/', Token.TOK_DIVIDE, Token.TOK_DIV);\n    }\n  }\n\n  private consumeLiteral(stream: string): JSONValue {\n    this._current += 1;\n    const start = this._current;\n    const maxLength = stream.length;\n\n    while (stream[this._current] !== '`' && this._current < maxLength) {\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\' || stream[current + 1] === '`')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    let literalString = stream.slice(start, this._current).trimStart();\n    literalString = literalString.replace('\\\\`', '`');\n\n    let literal: JSONValue = null;\n    let ok = false;\n\n    // attempts to detect and parse valid JSON\n\n    if (this.looksLikeJSON(literalString)) {\n      [literal, ok] = this.parseJSON(literalString);\n    }\n\n    // invalid JSON values should be converted to quoted\n    // JSON strings during the JEP-12 deprecation period.\n\n    if (!ok && this._enable_legacy_literals) {\n      [literal, ok] = this.parseJSON(`\"${literalString}\"`);\n    }\n\n    if (!ok) {\n      const error = new Error(\n        `Syntax error: unexpected end of JSON input or invalid format for a JSON literal: ${stream[this._current]}`,\n      );\n      error.name = 'LexerError';\n      throw error;\n    }\n\n    this._current += 1;\n    return literal;\n  }\n\n  private looksLikeJSON(literalString: string): boolean {\n    const startingChars = '[{\"';\n    const jsonLiterals = ['true', 'false', 'null'];\n    const numberLooking = '-0123456789';\n\n    if (literalString === '') {\n      return false;\n    }\n    if (startingChars.includes(literalString[0])) {\n      return true;\n    }\n    if (jsonLiterals.includes(literalString)) {\n      return true;\n    }\n    if (numberLooking.includes(literalString[0])) {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const [_, ok] = this.parseJSON(literalString);\n      return ok;\n    }\n    return false;\n  }\n\n  private parseJSON(text: string): [JSONValue, boolean] {\n    try {\n      const json = JSON.parse(text);\n      return [json, true];\n    } catch {\n      return [null, false];\n    }\n  }\n}\n\nexport const Lexer = new StreamLexer();\nexport default Lexer;\n","import type {\n  BinaryArithmeticNode,\n  BinaryExpressionNode,\n  BinaryOperatorType,\n  BindingNode,\n  ComparatorNode,\n  ComparatorType,\n  ExpressionNode,\n  FunctionNode,\n  IndexNode,\n  KeyValuePairNode,\n  LetExpressionNode,\n  SliceNode,\n  UnaryArithmeticNode,\n  UnaryExpressionNode,\n  VariableNode,\n} from './AST.type';\nimport Lexer from './Lexer';\nimport { LexerToken, Token } from './Lexer.type';\nimport { Options } from './Parser.type';\n\nconst bindingPower: Record<string, number> = {\n  [Token.TOK_EOF]: 0,\n  [Token.TOK_VARIABLE]: 0,\n  [Token.TOK_UNQUOTEDIDENTIFIER]: 0,\n  [Token.TOK_QUOTEDIDENTIFIER]: 0,\n  [Token.TOK_RBRACKET]: 0,\n  [Token.TOK_RPAREN]: 0,\n  [Token.TOK_COMMA]: 0,\n  [Token.TOK_RBRACE]: 0,\n  [Token.TOK_NUMBER]: 0,\n  [Token.TOK_CURRENT]: 0,\n  [Token.TOK_EXPREF]: 0,\n  [Token.TOK_ROOT]: 0,\n  [Token.TOK_ASSIGN]: 1,\n  [Token.TOK_PIPE]: 1,\n  [Token.TOK_QUESTION]: 2,\n  [Token.TOK_OR]: 3,\n  [Token.TOK_AND]: 4,\n  [Token.TOK_EQ]: 5,\n  [Token.TOK_GT]: 5,\n  [Token.TOK_LT]: 5,\n  [Token.TOK_GTE]: 5,\n  [Token.TOK_LTE]: 5,\n  [Token.TOK_NE]: 5,\n  [Token.TOK_MINUS]: 6,\n  [Token.TOK_PLUS]: 6,\n  [Token.TOK_DIV]: 7,\n  [Token.TOK_DIVIDE]: 7,\n  [Token.TOK_MODULO]: 7,\n  [Token.TOK_MULTIPLY]: 7,\n  [Token.TOK_FLATTEN]: 9,\n  [Token.TOK_STAR]: 20,\n  [Token.TOK_FILTER]: 21,\n  [Token.TOK_DOT]: 40,\n  [Token.TOK_NOT]: 45,\n  [Token.TOK_LBRACE]: 50,\n  [Token.TOK_LBRACKET]: 55,\n  [Token.TOK_LPAREN]: 60,\n};\n\nclass TokenParser {\n  index = 0;\n  tokens: LexerToken[] = [];\n\n  parse(expression: string, options?: Options): ExpressionNode {\n    this.loadTokens(expression, options || { enable_legacy_literals: false });\n    this.index = 0;\n\n    const ast = this.expression(0);\n    if (this.lookahead(0) !== Token.TOK_EOF) {\n      const token = this.lookaheadToken(0);\n      this.errorToken(token, `Syntax error: unexpected token type: ${token.type}, value: ${token.value}`);\n    }\n    return ast;\n  }\n\n  private loadTokens(expression: string, options: Options): void {\n    this.tokens = Lexer.tokenize(expression, options);\n    this.tokens.push({ type: Token.TOK_EOF, value: '', start: expression.length });\n  }\n\n  expression(rbp: number): ExpressionNode {\n    const leftToken = this.lookaheadToken(0);\n    this.advance();\n    let left = this.nud(leftToken);\n    let currentTokenType = this.lookahead(0);\n    while (rbp < bindingPower[currentTokenType]) {\n      this.advance();\n      left = this.led(currentTokenType, left);\n      currentTokenType = this.lookahead(0);\n    }\n    return left;\n  }\n\n  private lookahead(offset: number): Token {\n    return this.tokens[this.index + offset].type;\n  }\n\n  private lookaheadToken(offset: number): LexerToken {\n    return this.tokens[this.index + offset];\n  }\n\n  private advance(): void {\n    this.index += 1;\n  }\n\n  nud(token: LexerToken): ExpressionNode {\n    switch (token.type) {\n      case Token.TOK_VARIABLE:\n        return { type: 'Variable', name: token.value as string };\n      case Token.TOK_LITERAL:\n        return { type: 'Literal', value: token.value };\n      case Token.TOK_UNQUOTEDIDENTIFIER: {\n        if (TokenParser.isKeyword(token, 'let') && this.lookahead(0) === Token.TOK_VARIABLE) {\n          return this.parseLetExpression();\n        } else {\n          return { type: 'Field', name: token.value as string };\n        }\n      }\n      case Token.TOK_QUOTEDIDENTIFIER:\n        if (this.lookahead(0) === Token.TOK_LPAREN) {\n          throw new Error('Syntax error: quoted identifier not allowed for function names.');\n        } else {\n          return { type: 'Field', name: token.value as string };\n        }\n      case Token.TOK_NOT: {\n        const child = this.expression(bindingPower.Not);\n        return { type: 'NotExpression', child };\n      }\n      case Token.TOK_MINUS: {\n        const child = this.expression(bindingPower.Minus);\n        return {\n          type: 'Unary',\n          operator: token.type,\n          operand: child,\n        } as UnaryArithmeticNode;\n      }\n      case Token.TOK_PLUS: {\n        const child = this.expression(bindingPower.Plus);\n        return {\n          type: 'Unary',\n          operator: token.type,\n          operand: child,\n        } as UnaryArithmeticNode;\n      }\n      case Token.TOK_STAR: {\n        const left: ExpressionNode = { type: 'Identity' };\n        return { type: 'ValueProjection', left, right: this.parseProjectionRHS(bindingPower.Star) };\n      }\n      case Token.TOK_FILTER:\n        return this.led(token.type, { type: 'Identity' });\n      case Token.TOK_LBRACE:\n        return this.parseMultiselectHash();\n      case Token.TOK_FLATTEN: {\n        const left: ExpressionNode = {\n          type: 'Flatten',\n          child: { type: 'Identity' },\n        };\n        const right: ExpressionNode = this.parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', left, right };\n      }\n      case Token.TOK_LBRACKET: {\n        if (this.lookahead(0) === Token.TOK_NUMBER || this.lookahead(0) === Token.TOK_COLON) {\n          const right = this.parseIndexExpression();\n          return this.projectIfSlice({ type: 'Identity' }, right);\n        }\n        if (this.lookahead(0) === Token.TOK_STAR && this.lookahead(1) === Token.TOK_RBRACKET) {\n          this.advance();\n          this.advance();\n          const right = this.parseProjectionRHS(bindingPower.Star);\n          return {\n            left: { type: 'Identity' },\n            right,\n            type: 'Projection',\n          };\n        }\n        return this.parseMultiselectList();\n      }\n      case Token.TOK_CURRENT:\n        return { type: Token.TOK_CURRENT };\n      case Token.TOK_ROOT:\n        return { type: Token.TOK_ROOT };\n      case Token.TOK_EXPREF: {\n        const child = this.expression(bindingPower.Expref);\n        return { type: 'ExpressionReference', child };\n      }\n      case Token.TOK_LPAREN: {\n        const expression = this.expression(0);\n        this.match(Token.TOK_RPAREN);\n        return expression;\n      }\n      default:\n        this.errorToken(token);\n    }\n  }\n\n  led(tokenName: string, left: ExpressionNode): ExpressionNode {\n    switch (tokenName) {\n      case Token.TOK_QUESTION: {\n        const trueExpr = this.expression(0);\n        this.match(Token.TOK_COLON);\n        const falseExpr = this.expression(0);\n        return {\n          type: 'Ternary',\n          condition: left,\n          trueExpr,\n          falseExpr,\n        };\n      }\n      case Token.TOK_DOT: {\n        const rbp = bindingPower.Dot;\n        if (this.lookahead(0) !== Token.TOK_STAR) {\n          const right = this.parseDotRHS(rbp);\n          return { type: 'Subexpression', left, right };\n        }\n        this.advance();\n        const right = this.parseProjectionRHS(rbp);\n        return { type: 'ValueProjection', left, right };\n      }\n      case Token.TOK_PIPE: {\n        const right = this.expression(bindingPower.Pipe);\n        return { type: 'Pipe', left, right };\n      }\n      case Token.TOK_OR: {\n        const right = this.expression(bindingPower.Or);\n        return { type: 'OrExpression', left, right };\n      }\n      case Token.TOK_AND: {\n        const right = this.expression(bindingPower.And);\n        return { type: 'AndExpression', left, right };\n      }\n      case Token.TOK_LPAREN: {\n        if (left.type !== 'Field') {\n          throw new Error('Syntax error: expected a Field node');\n        }\n        const name = left.name;\n        const args = this.parseCommaSeparatedExpressionsUntilToken(Token.TOK_RPAREN);\n        const node: FunctionNode = { name, type: 'Function', children: args };\n        return node;\n      }\n      case Token.TOK_FILTER: {\n        const condition = this.expression(0);\n        this.match(Token.TOK_RBRACKET);\n        const right: ExpressionNode =\n          this.lookahead(0) === Token.TOK_FLATTEN ? { type: 'Identity' } : this.parseProjectionRHS(bindingPower.Filter);\n        return { type: 'FilterProjection', left, right, condition };\n      }\n      case Token.TOK_FLATTEN: {\n        const leftNode: UnaryExpressionNode = { type: 'Flatten', child: left };\n        const right = this.parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', left: leftNode, right };\n      }\n      case Token.TOK_ASSIGN: {\n        const leftNode = left as VariableNode;\n        const right = this.expression(0);\n        return {\n          type: 'Binding',\n          variable: leftNode.name,\n          reference: right,\n        };\n      }\n      case Token.TOK_EQ:\n      case Token.TOK_NE:\n      case Token.TOK_GT:\n      case Token.TOK_GTE:\n      case Token.TOK_LT:\n      case Token.TOK_LTE:\n        return this.parseComparator(left, tokenName);\n      case Token.TOK_PLUS:\n      case Token.TOK_MINUS:\n      case Token.TOK_MULTIPLY:\n      case Token.TOK_STAR:\n      case Token.TOK_DIVIDE:\n      case Token.TOK_MODULO:\n      case Token.TOK_DIV:\n        return this.parseArithmetic(left, tokenName);\n      case Token.TOK_LBRACKET: {\n        const token = this.lookaheadToken(0);\n        if (token.type === Token.TOK_NUMBER || token.type === Token.TOK_COLON) {\n          const right = this.parseIndexExpression();\n          return this.projectIfSlice(left, right);\n        }\n        this.match(Token.TOK_STAR);\n        this.match(Token.TOK_RBRACKET);\n        const right = this.parseProjectionRHS(bindingPower.Star);\n        return { type: 'Projection', left, right };\n      }\n\n      default:\n        return this.errorToken(this.lookaheadToken(0));\n    }\n  }\n\n  private static isKeyword(token: LexerToken, keyword: string): boolean {\n    return token.type === Token.TOK_UNQUOTEDIDENTIFIER && token.value === keyword;\n  }\n\n  private match(tokenType: Token | LexerToken): void {\n    if (this.lookahead(0) === tokenType) {\n      this.advance();\n      return;\n    } else {\n      const token = this.lookaheadToken(0);\n      this.errorToken(token, `Syntax error: expected ${tokenType}, got: ${token.type}`);\n    }\n  }\n\n  private errorToken(token: LexerToken, message = ''): never {\n    const error = new Error(message || `Syntax error: invalid token (${token.type}): \"${token.value}\"`);\n    error.name = 'ParserError';\n    throw error;\n  }\n\n  private parseIndexExpression(): SliceNode | IndexNode {\n    if (this.lookahead(0) === Token.TOK_COLON || this.lookahead(1) === Token.TOK_COLON) {\n      return this.parseSliceExpression();\n    }\n    const value = Number(this.lookaheadToken(0).value);\n    this.advance();\n    this.match(Token.TOK_RBRACKET);\n    return { type: 'Index', value };\n  }\n\n  private projectIfSlice(\n    left: ExpressionNode,\n    right: ExpressionNode,\n  ): BinaryExpressionNode<'Projection' | 'IndexExpression'> {\n    const indexExpr: BinaryExpressionNode<'IndexExpression'> = {\n      type: 'IndexExpression',\n      left,\n      right,\n    };\n    if (right.type === 'Slice') {\n      return {\n        left: indexExpr,\n        right: this.parseProjectionRHS(bindingPower.Star),\n        type: 'Projection',\n      };\n    }\n    return indexExpr;\n  }\n\n  private parseSliceExpression(): SliceNode {\n    const parts: (number | null)[] = [null, null, null];\n\n    let index = 0;\n    let current = this.lookaheadToken(0);\n\n    while (current.type != Token.TOK_RBRACKET && index < 3) {\n      if (current.type === Token.TOK_COLON) {\n        index++;\n        if (index === 3) {\n          this.errorToken(this.lookaheadToken(0), 'Syntax error, too many colons in slice expression');\n        }\n        this.advance();\n      } else if (current.type === Token.TOK_NUMBER) {\n        const part = this.lookaheadToken(0).value as number;\n        parts[index] = part;\n        this.advance();\n      } else {\n        const next = this.lookaheadToken(0);\n        this.errorToken(next, `Syntax error, unexpected token: ${next.value}(${next.type})`);\n      }\n\n      current = this.lookaheadToken(0);\n    }\n\n    this.match(Token.TOK_RBRACKET);\n\n    const [start, stop, step] = parts;\n    return { type: 'Slice', start, stop, step };\n  }\n\n  private parseLetExpression(): LetExpressionNode {\n    const separated = this.parseCommaSeparatedExpressionsUntilKeyword('in');\n    const expression = this.expression(0);\n    const bindings = separated.map(binding => binding as BindingNode);\n    return {\n      type: 'LetExpression',\n      bindings: bindings,\n      expression: expression,\n    };\n  }\n\n  private parseCommaSeparatedExpressionsUntilKeyword(keyword: string): ExpressionNode[] {\n    return this.parseCommaSeparatedExpressionsUntil(\n      () => {\n        return TokenParser.isKeyword(this.lookaheadToken(0), keyword);\n      },\n      () => {\n        this.advance();\n      },\n    );\n  }\n\n  private parseCommaSeparatedExpressionsUntilToken(token: Token): ExpressionNode[] {\n    return this.parseCommaSeparatedExpressionsUntil(\n      () => {\n        return this.lookahead(0) === token;\n      },\n      () => {\n        return this.match(token);\n      },\n    );\n  }\n\n  private parseCommaSeparatedExpressionsUntil(isEndToken: () => boolean, matchEndToken: () => void): ExpressionNode[] {\n    const args: ExpressionNode[] = [];\n    let expression: ExpressionNode;\n    while (!isEndToken()) {\n      expression = this.expression(0);\n      if (this.lookahead(0) === Token.TOK_COMMA) {\n        this.match(Token.TOK_COMMA);\n      }\n      args.push(expression);\n    }\n    matchEndToken();\n    return args;\n  }\n\n  private parseComparator(left: ExpressionNode, comparator: ComparatorType): ComparatorNode {\n    const right = this.expression(bindingPower[comparator]);\n    return { type: 'Comparator', name: comparator, left, right };\n  }\n\n  private parseArithmetic(left: ExpressionNode, operator: BinaryOperatorType): BinaryArithmeticNode {\n    const right = this.expression(bindingPower[operator]);\n    return { type: 'Arithmetic', operator: operator, left, right };\n  }\n\n  private parseDotRHS(rbp: number): ExpressionNode {\n    const lookahead = this.lookahead(0);\n    const exprTokens = [Token.TOK_UNQUOTEDIDENTIFIER, Token.TOK_QUOTEDIDENTIFIER, Token.TOK_STAR];\n    if (exprTokens.includes(lookahead)) {\n      return this.expression(rbp);\n    }\n    if (lookahead === Token.TOK_LBRACKET) {\n      this.match(Token.TOK_LBRACKET);\n      return this.parseMultiselectList();\n    }\n    if (lookahead === Token.TOK_LBRACE) {\n      this.match(Token.TOK_LBRACE);\n      return this.parseMultiselectHash();\n    }\n    const token = this.lookaheadToken(0);\n    this.errorToken(token, `Syntax error, unexpected token: ${token.value}(${token.type})`);\n  }\n\n  private parseProjectionRHS(rbp: number): ExpressionNode {\n    if (bindingPower[this.lookahead(0)] < 10) {\n      return { type: 'Identity' };\n    }\n    if (this.lookahead(0) === Token.TOK_LBRACKET) {\n      return this.expression(rbp);\n    }\n    if (this.lookahead(0) === Token.TOK_FILTER) {\n      return this.expression(rbp);\n    }\n    if (this.lookahead(0) === Token.TOK_DOT) {\n      this.match(Token.TOK_DOT);\n      return this.parseDotRHS(rbp);\n    }\n    const token = this.lookaheadToken(0);\n    this.errorToken(token, `Syntax error, unexpected token: ${token.value}(${token.type})`);\n  }\n\n  private parseMultiselectList(): ExpressionNode {\n    const expressions: ExpressionNode[] = [];\n    while (this.lookahead(0) !== Token.TOK_RBRACKET) {\n      const expression = this.expression(0);\n      expressions.push(expression);\n      if (this.lookahead(0) === Token.TOK_COMMA) {\n        this.match(Token.TOK_COMMA);\n        if (this.lookahead(0) === Token.TOK_RBRACKET) {\n          throw new Error('Syntax error: unexpected token Rbracket');\n        }\n      }\n    }\n    this.match(Token.TOK_RBRACKET);\n    return { type: 'MultiSelectList', children: expressions };\n  }\n\n  private parseMultiselectHash(): ExpressionNode {\n    const pairs: KeyValuePairNode[] = [];\n    const identifierTypes = [Token.TOK_UNQUOTEDIDENTIFIER, Token.TOK_QUOTEDIDENTIFIER];\n    let keyToken;\n    let keyName: string;\n    let value: ExpressionNode;\n    // tslint:disable-next-line: prettier\n    for (;;) {\n      keyToken = this.lookaheadToken(0);\n      if (!identifierTypes.includes(keyToken.type)) {\n        throw new Error(`Syntax error: expecting an identifier token, got: ${keyToken.type}`);\n      }\n      keyName = keyToken.value as string;\n      this.advance();\n      this.match(Token.TOK_COLON);\n      value = this.expression(0);\n      pairs.push({ value, type: 'KeyValuePair', name: keyName });\n      if (this.lookahead(0) === Token.TOK_COMMA) {\n        this.match(Token.TOK_COMMA);\n      } else if (this.lookahead(0) === Token.TOK_RBRACE) {\n        this.match(Token.TOK_RBRACE);\n        break;\n      }\n    }\n    return { type: 'MultiSelectHash', children: pairs };\n  }\n}\n\nexport const Parser = new TokenParser();\nexport default Parser;\n","export class Text {\n  private _text: string;\n  constructor(text: string) {\n    this._text = text;\n  }\n\n  public get string(): string {\n    return this._text;\n  }\n\n  public get length(): number {\n    return this.codePoints.length;\n  }\n\n  public compareTo(other: string): number {\n    return Text.compare(this, new Text(other));\n  }\n\n  public static get comparer(): (lhs: string, rhs: string) => number {\n    const stringComparer = (left: string, right: string): number => {\n      return new Text(left).compareTo(right);\n    };\n    return stringComparer;\n  }\n\n  public static compare(left: Text, right: Text): number {\n    const leftCp = left.codePoints;\n    const rightCp = right.codePoints;\n    for (let index = 0; index < Math.min(leftCp.length, rightCp.length); index++) {\n      if (leftCp[index] === rightCp[index]) {\n        continue;\n      }\n      return leftCp[index] - rightCp[index] > 0 ? 1 : -1;\n    }\n    return leftCp.length - rightCp.length > 0 ? 1 : -1;\n  }\n\n  public reverse(): string {\n    return String.fromCodePoint(...this.codePoints.reverse());\n  }\n\n  private get codePoints(): number[] {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    // biome-ignore lint: lint/style/noNonNullAssertion\n    const array = [...this._text].map(s => s.codePointAt(0)!);\n    return array;\n  }\n}\n","import type { ExpressionNode } from './AST.type';\nimport type {\n  JSONArray,\n  JSONArrayArray,\n  JSONArrayKeyValuePairs,\n  JSONArrayObject,\n  JSONObject,\n  JSONValue,\n  ObjectDict,\n} from './JSON.type';\nimport type { TreeInterpreter } from './TreeInterpreter';\nimport {\n  findFirst,\n  findLast,\n  lower,\n  padLeft,\n  padRight,\n  replace,\n  split,\n  trim,\n  trimLeft,\n  trimRight,\n  upper,\n} from './utils/strings';\nimport { Text } from './utils/text';\n\nexport enum InputArgument {\n  TYPE_NUMBER = 0,\n  TYPE_ANY = 1,\n  TYPE_STRING = 2,\n  TYPE_ARRAY = 3,\n  TYPE_OBJECT = 4,\n  TYPE_BOOLEAN = 5,\n  TYPE_EXPREF = 6,\n  TYPE_NULL = 7,\n  TYPE_ARRAY_NUMBER = 8,\n  TYPE_ARRAY_STRING = 9,\n  TYPE_ARRAY_OBJECT = 10,\n  TYPE_ARRAY_ARRAY = 11,\n}\n\nexport interface InputSignature {\n  types: InputArgument[];\n  variadic?: boolean;\n  optional?: boolean;\n}\n\nexport type RuntimeFunction<T extends (JSONValue | ExpressionNode)[], U> = (resolvedArgs: T) => U;\n\nexport interface FunctionSignature {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // biome-ignore lint: lint/suspicious/noExplicitAny\n  _func: RuntimeFunction<any, JSONValue>;\n  _signature: InputSignature[];\n}\n\nexport interface FunctionTable {\n  [functionName: string]: FunctionSignature;\n}\n\n// Built-in function names for TypeScript 5.x template literal type checking\nexport type BuiltInFunctionNames =\n  | 'abs'\n  | 'avg'\n  | 'ceil'\n  | 'contains'\n  | 'ends_with'\n  | 'find_first'\n  | 'find_last'\n  | 'floor'\n  | 'from_items'\n  | 'group_by'\n  | 'items'\n  | 'join'\n  | 'keys'\n  | 'length'\n  | 'lower'\n  | 'map'\n  | 'max'\n  | 'max_by'\n  | 'merge'\n  | 'min'\n  | 'min_by'\n  | 'not_null'\n  | 'pad_left'\n  | 'pad_right'\n  | 'replace'\n  | 'reverse'\n  | 'sort'\n  | 'sort_by'\n  | 'split'\n  | 'starts_with'\n  | 'sum'\n  | 'to_array'\n  | 'to_number'\n  | 'to_string'\n  | 'type'\n  | 'upper'\n  | 'values'\n  | 'zip';\n\n// Registration options for enhanced registerFunction behavior\nexport interface RegisterOptions {\n  /**\n   * Allow overriding existing functions. Default: false\n   * When true, replaces existing function without error\n   * When false, throws error if function already exists (backward compatible)\n   */\n  override?: boolean;\n  /**\n   * Emit warning when overriding existing functions. Default: false\n   * Only applies when override is true\n   */\n  warn?: boolean;\n}\n\n// Registration result for better error handling and introspection\nexport type RegistrationResult =\n  | { success: true; message?: string }\n  | { success: false; reason: 'already-exists' | 'invalid-signature' | 'invalid-name'; message: string };\n\n// Enhanced function registry interface for state management\nexport interface FunctionRegistry {\n  /**\n   * Register a new function with optional override behavior\n   */\n  register<T extends string>(\n    name: T extends BuiltInFunctionNames ? never : T,\n    func: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n    signature: InputSignature[],\n    options?: RegisterOptions,\n  ): RegistrationResult;\n\n  /**\n   * Unregister a custom function (built-in functions cannot be unregistered)\n   */\n  unregister<T extends string>(name: T extends BuiltInFunctionNames ? never : T): boolean;\n\n  /**\n   * Check if a function is registered\n   */\n  isRegistered(name: string): boolean;\n\n  /**\n   * Get list of all registered function names\n   */\n  getRegistered(): string[];\n\n  /**\n   * Get list of custom (non-built-in) function names\n   */\n  getCustomFunctions(): string[];\n\n  /**\n   * Clear all custom functions (built-in functions remain)\n   */\n  clearCustomFunctions(): void;\n}\n\n// Factory functions for common function patterns\nconst createMathFunction =\n  (mathFn: (n: number) => number): RuntimeFunction<[number], number> =>\n  ([value]) =>\n    mathFn(value);\n\nconst createStringFunction =\n  (stringFn: (s: string) => string): RuntimeFunction<[string], string> =>\n  ([subject]) =>\n    stringFn(subject);\n\nconst createObjectFunction =\n  <T>(objFn: (obj: JSONObject) => T): RuntimeFunction<[JSONObject], T> =>\n  ([obj]) =>\n    objFn(obj);\n\nexport class Runtime implements FunctionRegistry {\n  _interpreter: TreeInterpreter;\n  _functionTable: FunctionTable;\n  private _customFunctions: Set<string> = new Set();\n  TYPE_NAME_TABLE = Object.freeze({\n    [InputArgument.TYPE_NUMBER]: 'number',\n    [InputArgument.TYPE_ANY]: 'any',\n    [InputArgument.TYPE_STRING]: 'string',\n    [InputArgument.TYPE_ARRAY]: 'array',\n    [InputArgument.TYPE_OBJECT]: 'object',\n    [InputArgument.TYPE_BOOLEAN]: 'boolean',\n    [InputArgument.TYPE_EXPREF]: 'expression',\n    [InputArgument.TYPE_NULL]: 'null',\n    [InputArgument.TYPE_ARRAY_NUMBER]: 'Array<number>',\n    [InputArgument.TYPE_ARRAY_OBJECT]: 'Array<object>',\n    [InputArgument.TYPE_ARRAY_STRING]: 'Array<string>',\n    [InputArgument.TYPE_ARRAY_ARRAY]: 'Array<Array<any>>',\n  } as const);\n\n  constructor(interpreter: TreeInterpreter) {\n    this._interpreter = interpreter;\n    this._functionTable = this.buildFunctionTable();\n  }\n\n  private buildFunctionTable(): FunctionTable {\n    return {\n      // Math functions\n      abs: { _func: createMathFunction(Math.abs), _signature: [{ types: [InputArgument.TYPE_NUMBER] }] },\n      ceil: { _func: createMathFunction(Math.ceil), _signature: [{ types: [InputArgument.TYPE_NUMBER] }] },\n      floor: { _func: createMathFunction(Math.floor), _signature: [{ types: [InputArgument.TYPE_NUMBER] }] },\n\n      // String functions\n      lower: { _func: createStringFunction(lower), _signature: [{ types: [InputArgument.TYPE_STRING] }] },\n      upper: { _func: createStringFunction(upper), _signature: [{ types: [InputArgument.TYPE_STRING] }] },\n\n      // Object functions\n      keys: { _func: createObjectFunction(Object.keys), _signature: [{ types: [InputArgument.TYPE_OBJECT] }] },\n      values: { _func: createObjectFunction(Object.values), _signature: [{ types: [InputArgument.TYPE_OBJECT] }] },\n\n      // Complex functions that need custom implementations\n      avg: { _func: this.functionAvg, _signature: [{ types: [InputArgument.TYPE_ARRAY_NUMBER] }] },\n      contains: {\n        _func: this.functionContains,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY] },\n          { types: [InputArgument.TYPE_ANY] },\n        ],\n      },\n      ends_with: {\n        _func: this.functionEndsWith,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_STRING] }],\n      },\n      find_first: {\n        _func: this.functionFindFirst,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n        ],\n      },\n      find_last: {\n        _func: this.functionFindLast,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n        ],\n      },\n      from_items: { _func: this.functionFromItems, _signature: [{ types: [InputArgument.TYPE_ARRAY_ARRAY] }] },\n      group_by: {\n        _func: this.functionGroupBy,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY] }, { types: [InputArgument.TYPE_EXPREF] }],\n      },\n      items: { _func: this.functionItems, _signature: [{ types: [InputArgument.TYPE_OBJECT] }] },\n      join: {\n        _func: this.functionJoin,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_ARRAY_STRING] }],\n      },\n      length: {\n        _func: this.functionLength,\n        _signature: [{ types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY, InputArgument.TYPE_OBJECT] }],\n      },\n      map: {\n        _func: this.functionMap,\n        _signature: [{ types: [InputArgument.TYPE_EXPREF] }, { types: [InputArgument.TYPE_ARRAY] }],\n      },\n      max: {\n        _func: this.functionMax,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY_NUMBER, InputArgument.TYPE_ARRAY_STRING] }],\n      },\n      max_by: {\n        _func: this.functionMaxBy,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY] }, { types: [InputArgument.TYPE_EXPREF] }],\n      },\n      merge: { _func: this.functionMerge, _signature: [{ types: [InputArgument.TYPE_OBJECT], variadic: true }] },\n      min: {\n        _func: this.functionMin,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY_NUMBER, InputArgument.TYPE_ARRAY_STRING] }],\n      },\n      min_by: {\n        _func: this.functionMinBy,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY] }, { types: [InputArgument.TYPE_EXPREF] }],\n      },\n      not_null: { _func: this.functionNotNull, _signature: [{ types: [InputArgument.TYPE_ANY], variadic: true }] },\n      pad_left: {\n        _func: this.functionPadLeft,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER] },\n          { types: [InputArgument.TYPE_STRING], optional: true },\n        ],\n      },\n      pad_right: {\n        _func: this.functionPadRight,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER] },\n          { types: [InputArgument.TYPE_STRING], optional: true },\n        ],\n      },\n      replace: {\n        _func: this.functionReplace,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n        ],\n      },\n      reverse: {\n        _func: this.functionReverse,\n        _signature: [{ types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY] }],\n      },\n      sort: {\n        _func: this.functionSort,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY_STRING, InputArgument.TYPE_ARRAY_NUMBER] }],\n      },\n      sort_by: {\n        _func: this.functionSortBy,\n        _signature: [{ types: [InputArgument.TYPE_ARRAY] }, { types: [InputArgument.TYPE_EXPREF] }],\n      },\n      split: {\n        _func: this.functionSplit,\n        _signature: [\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_STRING] },\n          { types: [InputArgument.TYPE_NUMBER], optional: true },\n        ],\n      },\n      starts_with: {\n        _func: this.functionStartsWith,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_STRING] }],\n      },\n      sum: { _func: this.functionSum, _signature: [{ types: [InputArgument.TYPE_ARRAY_NUMBER] }] },\n      to_array: { _func: this.functionToArray, _signature: [{ types: [InputArgument.TYPE_ANY] }] },\n      to_number: { _func: this.functionToNumber, _signature: [{ types: [InputArgument.TYPE_ANY] }] },\n      to_string: { _func: this.functionToString, _signature: [{ types: [InputArgument.TYPE_ANY] }] },\n      trim: {\n        _func: this.functionTrim,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_STRING], optional: true }],\n      },\n      trim_left: {\n        _func: this.functionTrimLeft,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_STRING], optional: true }],\n      },\n      trim_right: {\n        _func: this.functionTrimRight,\n        _signature: [{ types: [InputArgument.TYPE_STRING] }, { types: [InputArgument.TYPE_STRING], optional: true }],\n      },\n      type: { _func: this.functionType, _signature: [{ types: [InputArgument.TYPE_ANY] }] },\n      zip: { _func: this.functionZip, _signature: [{ types: [InputArgument.TYPE_ARRAY], variadic: true }] },\n    };\n  }\n\n  /**\n   * Enhanced registerFunction with backward compatibility and new options\n   * @deprecated Use register() method for enhanced functionality\n   */\n  registerFunction(\n    name: string,\n    customFunction: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n    signature: InputSignature[],\n    options?: RegisterOptions,\n  ): void {\n    // For backward compatibility, we bypass the type checking here\n    // The register method will still validate the function name at runtime\n    const result = this._registerInternal(name, customFunction, signature, options);\n    if (!result.success) {\n      throw new Error(result.message);\n    }\n  }\n\n  /**\n   * Internal registration method that bypasses TypeScript type checking\n   */\n  private _registerInternal(\n    name: string,\n    customFunction: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n    signature: InputSignature[],\n    options: RegisterOptions = {},\n  ): RegistrationResult {\n    // Validate function name\n    if (!name || typeof name !== 'string' || name.trim() === '') {\n      return {\n        success: false,\n        reason: 'invalid-name',\n        message: 'Function name must be a non-empty string',\n      };\n    }\n\n    // Validate signature\n    try {\n      this.validateInputSignatures(name, signature);\n    } catch (error) {\n      return {\n        success: false,\n        reason: 'invalid-signature',\n        message: error instanceof Error ? error.message : 'Invalid function signature',\n      };\n    }\n\n    const { override = false, warn = false } = options;\n    const exists = name in this._functionTable;\n\n    // Handle existing function\n    if (exists && !override) {\n      return {\n        success: false,\n        reason: 'already-exists',\n        message: `Function already defined: ${name}(). Use { override: true } to replace it.`,\n      };\n    }\n\n    // Emit warning if requested\n    if (exists && override && warn) {\n      console.warn(`Warning: Overriding existing function: ${name}()`);\n    }\n\n    // Register the function\n    this._functionTable[name] = {\n      _func: customFunction.bind(this),\n      _signature: signature,\n    };\n\n    // Track custom functions (exclude built-ins)\n    this._customFunctions.add(name);\n\n    const message = exists\n      ? `Function ${name}() overridden successfully`\n      : `Function ${name}() registered successfully`;\n    return { success: true, message };\n  }\n\n  /**\n   * Register a new function with enhanced options and type safety\n   */\n  register<T extends string>(\n    name: T extends BuiltInFunctionNames ? never : T,\n    customFunction: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n    signature: InputSignature[],\n    options: RegisterOptions = {},\n  ): RegistrationResult {\n    return this._registerInternal(name, customFunction, signature, options);\n  }\n\n  /**\n   * Unregister a custom function (built-in functions cannot be unregistered)\n   */\n  unregister<T extends string>(name: T extends BuiltInFunctionNames ? never : T): boolean {\n    if (!this._customFunctions.has(name)) {\n      return false; // Function doesn't exist or is built-in\n    }\n\n    delete this._functionTable[name];\n    this._customFunctions.delete(name);\n    return true;\n  }\n\n  /**\n   * Check if a function is registered\n   */\n  isRegistered(name: string): boolean {\n    return name in this._functionTable;\n  }\n\n  /**\n   * Get list of all registered function names\n   */\n  getRegistered(): string[] {\n    return Object.keys(this._functionTable);\n  }\n\n  /**\n   * Get list of custom (non-built-in) function names\n   */\n  getCustomFunctions(): string[] {\n    return Array.from(this._customFunctions);\n  }\n\n  /**\n   * Clear all custom functions (built-in functions remain)\n   */\n  clearCustomFunctions(): void {\n    for (const name of this._customFunctions) {\n      delete this._functionTable[name];\n    }\n    this._customFunctions.clear();\n  }\n\n  callFunction(name: string, resolvedArgs: (JSONValue | ExpressionNode)[]): JSONValue {\n    const functionEntry = this._functionTable[name];\n    if (functionEntry === undefined) {\n      throw new Error(`Unknown function: ${name}()`);\n    }\n    this.validateArgs(name, resolvedArgs, functionEntry._signature);\n    return functionEntry._func.call(this, resolvedArgs);\n  }\n\n  private validateInputSignatures(name: string, signature: InputSignature[]): void {\n    for (let i = 0; i < signature.length; i += 1) {\n      if ('variadic' in signature[i] && i !== signature.length - 1) {\n        throw new Error(`Invalid arity: ${name}() 'variadic' argument ${i + 1} must occur last`);\n      }\n    }\n  }\n\n  private validateArgs(name: string, args: (JSONValue | ExpressionNode)[], signature: InputSignature[]): void {\n    this.validateInputSignatures(name, signature);\n    this.validateArity(name, args, signature);\n    this.validateTypes(name, args, signature);\n  }\n\n  private validateArity(name: string, args: (JSONValue | ExpressionNode)[], signature: InputSignature[]): void {\n    const numberOfRequiredArgs = signature.filter(argSignature => !(argSignature.optional ?? false)).length;\n    const lastArgIsVariadic = signature[signature.length - 1]?.variadic ?? false;\n    const tooFewArgs = args.length < numberOfRequiredArgs;\n    const tooManyArgs = args.length > signature.length;\n\n    if ((lastArgIsVariadic && tooFewArgs) || (!lastArgIsVariadic && (tooFewArgs || tooManyArgs))) {\n      const tooFewModifier =\n        tooFewArgs && ((!lastArgIsVariadic && numberOfRequiredArgs > 1) || lastArgIsVariadic) ? 'at least ' : '';\n      const pluralized = signature.length > 1;\n      throw new Error(\n        `Invalid arity: ${name}() takes ${tooFewModifier}${numberOfRequiredArgs} argument${\n          (pluralized && 's') || ''\n        } but received ${args.length}`,\n      );\n    }\n  }\n\n  private validateTypes(name: string, args: (JSONValue | ExpressionNode)[], signature: InputSignature[]): void {\n    for (let i = 0; i < signature.length; i += 1) {\n      const currentSpec = signature[i].types;\n      const actualType = this.getTypeName(args[i]) as InputArgument;\n\n      if (actualType === undefined) {\n        continue;\n      }\n\n      const typeMatched = currentSpec.some(expectedType => this.typeMatches(actualType, expectedType, args[i]));\n\n      if (!typeMatched) {\n        const expected = currentSpec.map(typeId => this.TYPE_NAME_TABLE[typeId]).join(' | ');\n        throw new Error(\n          `Invalid type: ${name}() expected argument ${i + 1} to be type (${expected}) but received type ${\n            this.TYPE_NAME_TABLE[actualType]\n          } instead.`,\n        );\n      }\n    }\n  }\n\n  private typeMatches(actual: InputArgument, expected: InputArgument, argValue: unknown): boolean {\n    if (expected === InputArgument.TYPE_ANY) {\n      return true;\n    }\n    if (\n      expected === InputArgument.TYPE_ARRAY_STRING ||\n      expected === InputArgument.TYPE_ARRAY_NUMBER ||\n      expected === InputArgument.TYPE_ARRAY_OBJECT ||\n      expected === InputArgument.TYPE_ARRAY_ARRAY ||\n      expected === InputArgument.TYPE_ARRAY\n    ) {\n      if (expected === InputArgument.TYPE_ARRAY) {\n        return actual === InputArgument.TYPE_ARRAY;\n      }\n      if (actual === InputArgument.TYPE_ARRAY) {\n        let subtype;\n        if (expected === InputArgument.TYPE_ARRAY_NUMBER) {\n          subtype = InputArgument.TYPE_NUMBER;\n        } else if (expected === InputArgument.TYPE_ARRAY_OBJECT) {\n          subtype = InputArgument.TYPE_OBJECT;\n        } else if (expected === InputArgument.TYPE_ARRAY_STRING) {\n          subtype = InputArgument.TYPE_STRING;\n        } else if (expected === InputArgument.TYPE_ARRAY_ARRAY) {\n          subtype = InputArgument.TYPE_ARRAY;\n        }\n        const array = <JSONValue[]>argValue;\n        for (let i = 0; i < array.length; i += 1) {\n          const typeName = this.getTypeName(array[i]);\n          if (typeName !== undefined && subtype !== undefined && !this.typeMatches(typeName, subtype, array[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    } else {\n      return actual === expected;\n    }\n    return false;\n  }\n  private getTypeName(obj: JSONValue | ExpressionNode): InputArgument | undefined {\n    if (obj === null) {\n      return InputArgument.TYPE_NULL;\n    }\n    if (typeof obj === 'string') {\n      return InputArgument.TYPE_STRING;\n    }\n    if (typeof obj === 'number') {\n      return InputArgument.TYPE_NUMBER;\n    }\n    if (typeof obj === 'boolean') {\n      return InputArgument.TYPE_BOOLEAN;\n    }\n    if (Array.isArray(obj)) {\n      return InputArgument.TYPE_ARRAY;\n    }\n    if (typeof obj === 'object') {\n      if ((obj as ObjectDict).expref) {\n        return InputArgument.TYPE_EXPREF;\n      }\n      return InputArgument.TYPE_OBJECT;\n    }\n    return;\n  }\n\n  createKeyFunction(exprefNode: ExpressionNode, allowedTypes: InputArgument[]): (x: JSONValue) => JSONValue {\n    const interpreter = this._interpreter;\n    const keyFunc = (x: JSONValue): JSONValue => {\n      const current = interpreter.visit(exprefNode, x) as JSONValue;\n      if (!allowedTypes.includes(this.getTypeName(current) as InputArgument)) {\n        const msg = `Invalid type: expected one of (${allowedTypes\n          .map(t => this.TYPE_NAME_TABLE[t])\n          .join(' | ')}), received ${this.TYPE_NAME_TABLE[this.getTypeName(current) as InputArgument]}`;\n        throw new Error(msg);\n      }\n      return current;\n    };\n    return keyFunc;\n  }\n\n  private functionAvg: RuntimeFunction<[number[]], number | null> = ([inputArray]) => {\n    if (!inputArray || inputArray.length == 0) {\n      return null;\n    }\n\n    let sum = 0;\n    for (let i = 0; i < inputArray.length; i += 1) {\n      sum += inputArray[i];\n    }\n    return sum / inputArray.length;\n  };\n\n  private functionContains: RuntimeFunction<[string[] | JSONArray, JSONValue], JSONValue> = ([\n    searchable,\n    searchValue,\n  ]) => {\n    if (Array.isArray(searchable)) {\n      const array = <JSONArray>searchable;\n      return array.includes(searchValue);\n    }\n\n    if (typeof searchable === 'string') {\n      const text = <string>searchable;\n      if (typeof searchValue === 'string') {\n        return text.includes(searchValue);\n      }\n    }\n\n    return null;\n  };\n\n  private functionEndsWith: RuntimeFunction<[string, string], boolean> = resolvedArgs => {\n    const [searchStr, suffix] = resolvedArgs;\n    return searchStr.includes(suffix, searchStr.length - suffix.length);\n  };\n\n  private functionFindFirst = this.createFindFunction(findFirst);\n  private functionFindLast = this.createFindFunction(findLast);\n\n  private createFindFunction(\n    findFn: (subject: string, search: string, start?: number, end?: number) => number | null,\n  ): RuntimeFunction<JSONValue[], number | null> {\n    return resolvedArgs => {\n      const subject = resolvedArgs[0] as string;\n      const search = resolvedArgs[1] as string;\n      const start = resolvedArgs.length > 2 ? (resolvedArgs[2] as number) : undefined;\n      const end = resolvedArgs.length > 3 ? (resolvedArgs[3] as number) : undefined;\n      return findFn(subject, search, start, end);\n    };\n  }\n\n  private functionFromItems: RuntimeFunction<[JSONArrayKeyValuePairs], JSONObject> = ([array]) => {\n    array.map((pair: [string, JSONValue]) => {\n      if (pair.length != 2 || typeof pair[0] !== 'string') {\n        throw new Error('invalid value, each array must contain two elements, a pair of string and value');\n      }\n    });\n    return Object.fromEntries(array);\n  };\n\n  private functionGroupBy: RuntimeFunction<[JSONArrayObject, ExpressionNode], JSONValue> = ([array, exprefNode]) => {\n    const keyFunction = this.createKeyFunction(exprefNode, [InputArgument.TYPE_STRING]);\n    return array.reduce((acc, cur) => {\n      const k = keyFunction(cur ?? {});\n      const target = <JSONArray>(acc[<string>k] = acc[<string>k] || []);\n      target.push(cur);\n      return acc;\n    }, {});\n  };\n\n  private functionItems: RuntimeFunction<[JSONObject], JSONArray> = ([inputValue]) => {\n    return Object.entries(inputValue);\n  };\n\n  private functionJoin: RuntimeFunction<[string, string[]], string> = resolvedArgs => {\n    const [joinChar, listJoin] = resolvedArgs;\n    return listJoin.join(joinChar);\n  };\n\n  private functionLength: RuntimeFunction<[string | JSONArray | JSONObject], number> = ([inputValue]) => {\n    if (typeof inputValue === 'string') {\n      return new Text(inputValue).length;\n    }\n    if (Array.isArray(inputValue)) {\n      return inputValue.length;\n    }\n    return Object.keys(inputValue).length;\n  };\n\n  private functionMap: RuntimeFunction<[ExpressionNode, JSONArray], JSONArray> = ([exprefNode, elements]) => {\n    if (!this._interpreter) {\n      return [];\n    }\n    const mapped = [];\n    const interpreter = this._interpreter;\n    for (let i = 0; i < elements.length; i += 1) {\n      mapped.push(<JSONValue>interpreter.visit(exprefNode, elements[i]));\n    }\n    return mapped;\n  };\n\n  private functionMax: RuntimeFunction<[(string | number)[]], string | number | null> = ([inputValue]) => {\n    if (!inputValue.length) {\n      return null;\n    }\n\n    const typeName = this.getTypeName(inputValue[0]);\n    if (typeName === InputArgument.TYPE_NUMBER) {\n      return Math.max(...(inputValue as number[]));\n    }\n\n    const elements = inputValue as string[];\n    let maxElement = elements[0];\n    for (let i = 1; i < elements.length; i += 1) {\n      if (maxElement.localeCompare(elements[i]) < 0) {\n        maxElement = elements[i];\n      }\n    }\n    return maxElement;\n  };\n\n  private functionMaxBy: RuntimeFunction<[number[] | string[], ExpressionNode], JSONValue> = resolvedArgs => {\n    const exprefNode = resolvedArgs[1];\n    const resolvedArray = resolvedArgs[0];\n    const keyFunction = this.createKeyFunction(exprefNode, [InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING]);\n    let maxNumber = -Infinity;\n    let maxRecord!: JSONValue;\n    let current: number | undefined;\n    for (let i = 0; i < resolvedArray.length; i += 1) {\n      current = keyFunction && (keyFunction(resolvedArray[i]) as number);\n      if (current !== undefined && current > maxNumber) {\n        maxNumber = current;\n        maxRecord = resolvedArray[i];\n      }\n    }\n    return maxRecord || null;\n  };\n\n  private functionMerge: RuntimeFunction<JSONObject[], JSONObject> = resolvedArgs => {\n    let merged = {};\n    for (let i = 0; i < resolvedArgs.length; i += 1) {\n      const current = resolvedArgs[i];\n      merged = Object.assign(merged, current);\n    }\n    return merged;\n  };\n\n  private functionMin: RuntimeFunction<[(string | number)[]], string | number | null> = ([inputValue]) => {\n    if (!inputValue.length) {\n      return null;\n    }\n\n    const typeName = this.getTypeName(inputValue[0]);\n    if (typeName === InputArgument.TYPE_NUMBER) {\n      return Math.min(...(inputValue as number[]));\n    }\n\n    const elements = inputValue as string[];\n    let minElement = elements[0];\n    for (let i = 1; i < elements.length; i += 1) {\n      if (elements[i].localeCompare(minElement) < 0) {\n        minElement = elements[i];\n      }\n    }\n    return minElement;\n  };\n\n  private functionMinBy: RuntimeFunction<[number[] | string[], ExpressionNode], JSONValue> = resolvedArgs => {\n    const exprefNode = resolvedArgs[1];\n    const resolvedArray = resolvedArgs[0];\n    const keyFunction = this.createKeyFunction(exprefNode, [InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING]);\n    let minNumber = Infinity;\n    let minRecord!: JSONValue;\n    let current: number | undefined;\n    for (let i = 0; i < resolvedArray.length; i += 1) {\n      current = keyFunction && (keyFunction(resolvedArray[i]) as number);\n      if (current !== undefined && current < minNumber) {\n        minNumber = current;\n        minRecord = resolvedArray[i];\n      }\n    }\n    return minRecord || null;\n  };\n\n  private functionNotNull: RuntimeFunction<JSONArray, JSONValue> = resolvedArgs => {\n    for (let i = 0; i < resolvedArgs.length; i += 1) {\n      if (this.getTypeName(resolvedArgs[i]) !== InputArgument.TYPE_NULL) {\n        return resolvedArgs[i];\n      }\n    }\n    return null;\n  };\n\n  private functionPadLeft = this.createPadFunction(padLeft);\n  private functionPadRight = this.createPadFunction(padRight);\n\n  private createPadFunction(\n    padFn: (subject: string, width: number, padding?: string) => string,\n  ): RuntimeFunction<JSONValue[], string> {\n    return resolvedArgs => {\n      const subject = resolvedArgs[0] as string;\n      const width = resolvedArgs[1] as number;\n      const padding = resolvedArgs.length > 2 ? (resolvedArgs[2] as string) : undefined;\n      return padFn(subject, width, padding);\n    };\n  }\n\n  private functionReplace: RuntimeFunction<JSONValue[], string> = resolvedArgs => {\n    const subject = <string>resolvedArgs[0];\n    const string = <string>resolvedArgs[1];\n    const by = <string>resolvedArgs[2];\n    return replace(subject, string, by, resolvedArgs.length > 3 ? <number>resolvedArgs[3] : undefined);\n  };\n\n  private functionSplit: RuntimeFunction<JSONValue[], string[]> = resolvedArgs => {\n    const subject = <string>resolvedArgs[0];\n    const search = <string>resolvedArgs[1];\n    return split(subject, search, resolvedArgs.length > 2 ? <number>resolvedArgs[2] : undefined);\n  };\n\n  private functionReverse: RuntimeFunction<[string | JSONArray], string | JSONArray> = ([inputValue]) => {\n    const typeName = this.getTypeName(inputValue);\n    if (typeName === InputArgument.TYPE_STRING) {\n      return new Text(inputValue as string).reverse();\n    }\n    const reversedArray = (inputValue as JSONArray).slice(0);\n    reversedArray.reverse();\n    return reversedArray;\n  };\n\n  private functionSort: RuntimeFunction<[(string | number)[]], (string | number)[]> = ([inputValue]) => {\n    if (inputValue.length == 0) {\n      return inputValue;\n    }\n    if (typeof inputValue[0] === 'string') {\n      return (<string[]>[...inputValue]).sort(Text.comparer);\n    }\n    return [...inputValue].sort();\n  };\n\n  private functionSortBy: RuntimeFunction<[number[] | string[], ExpressionNode], JSONValue> = resolvedArgs => {\n    const sortedArray = resolvedArgs[0].slice(0);\n    if (sortedArray.length === 0) {\n      return sortedArray;\n    }\n    const interpreter = this._interpreter;\n    const exprefNode = resolvedArgs[1];\n    const requiredType = this.getTypeName(interpreter.visit(exprefNode, sortedArray[0]) as JSONValue);\n    if (requiredType !== undefined && ![InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING].includes(requiredType)) {\n      throw new Error(`Invalid type: unexpected type (${this.TYPE_NAME_TABLE[requiredType]})`);\n    }\n    function throwInvalidTypeError(rt: Runtime, item: string | number): never {\n      throw new Error(\n        `Invalid type: expected (${rt.TYPE_NAME_TABLE[requiredType as InputArgument]}), received ${\n          rt.TYPE_NAME_TABLE[rt.getTypeName(item) as InputArgument]\n        }`,\n      );\n    }\n\n    return sortedArray.sort((a, b) => {\n      const exprA = interpreter.visit(exprefNode, a) as number | string;\n      const exprB = interpreter.visit(exprefNode, b) as number | string;\n      if (this.getTypeName(exprA) !== requiredType) {\n        throwInvalidTypeError(this, exprA);\n      } else if (this.getTypeName(exprB) !== requiredType) {\n        throwInvalidTypeError(this, exprB);\n      }\n      if (requiredType === InputArgument.TYPE_STRING) {\n        return Text.comparer(<string>exprA, <string>exprB);\n      }\n      return <number>exprA - <number>exprB;\n    });\n  };\n\n  private functionStartsWith: RuntimeFunction<[string, string], boolean> = ([searchable, searchStr]) => {\n    return searchable.startsWith(searchStr);\n  };\n\n  private functionSum: RuntimeFunction<[number[]], number> = ([inputValue]) => {\n    return inputValue.reduce((x, y) => x + y, 0);\n  };\n\n  private functionToArray: RuntimeFunction<[JSONValue], JSONArray> = ([inputValue]) => {\n    if (this.getTypeName(inputValue) === InputArgument.TYPE_ARRAY) {\n      return inputValue as JSONArray;\n    }\n    return [inputValue];\n  };\n\n  private functionToNumber: RuntimeFunction<[JSONValue], number | null> = ([inputValue]) => {\n    const typeName = this.getTypeName(inputValue);\n    let convertedValue: number;\n    if (typeName === InputArgument.TYPE_NUMBER) {\n      return inputValue as number;\n    }\n    if (typeName === InputArgument.TYPE_STRING) {\n      convertedValue = +(inputValue as string);\n      if (!isNaN(convertedValue)) {\n        return convertedValue;\n      }\n    }\n    return null;\n  };\n\n  private functionToString: RuntimeFunction<[JSONValue], string> = ([inputValue]) => {\n    if (this.getTypeName(inputValue) === InputArgument.TYPE_STRING) {\n      return inputValue as string;\n    }\n    return JSON.stringify(inputValue);\n  };\n\n  private functionTrim = this.createTrimFunction(trim);\n  private functionTrimLeft = this.createTrimFunction(trimLeft);\n  private functionTrimRight = this.createTrimFunction(trimRight);\n\n  private createTrimFunction(\n    trimFn: (subject: string, chars?: string) => string,\n  ): RuntimeFunction<JSONValue[], string> {\n    return resolvedArgs => {\n      const subject = resolvedArgs[0] as string;\n      const chars = resolvedArgs.length > 1 ? (resolvedArgs[1] as string) : undefined;\n      return trimFn(subject, chars);\n    };\n  }\n\n  private functionType: RuntimeFunction<[JSONValue], string> = ([inputValue]) => {\n    switch (this.getTypeName(inputValue)) {\n      case InputArgument.TYPE_NUMBER:\n        return 'number';\n      case InputArgument.TYPE_STRING:\n        return 'string';\n      case InputArgument.TYPE_ARRAY:\n        return 'array';\n      case InputArgument.TYPE_OBJECT:\n        return 'object';\n      case InputArgument.TYPE_BOOLEAN:\n        return 'boolean';\n      case InputArgument.TYPE_NULL:\n        return 'null';\n      default:\n        throw new Error('invalid-type');\n    }\n  };\n\n  private functionZip: RuntimeFunction<JSONArrayArray, JSONArray> = array => {\n    const length = Math.min(...array.map(arr => arr.length));\n    const result = Array(length)\n      .fill(null)\n      .map((_, index) => array.map(arr => arr[index]));\n    return result;\n  };\n}\n","import { JSONObject, JSONValue } from './JSON.type';\n\nexport class ScopeChain {\n  private inner?: ScopeChain = undefined;\n  private data: JSONObject = {};\n\n  get currentScopeData(): JSONObject {\n    return this.data;\n  }\n\n  public withScope(data: JSONObject): ScopeChain {\n    const outer: ScopeChain = new ScopeChain();\n    outer.inner = this;\n    outer.data = data;\n    return outer;\n  }\n\n  public getValue(identifier: string): JSONValue {\n    if (Object.prototype.hasOwnProperty.call(this.data, identifier)) {\n      return this.data[identifier];\n    }\n\n    if (this.inner) {\n      return this.inner.getValue(identifier);\n    }\n\n    return null;\n  }\n}\n","import type { ExpressionNode, ExpressionReference, SliceNode } from './AST.type';\nimport type { JSONArray, JSONObject, JSONValue } from './JSON.type';\nimport { Token } from './Lexer.type';\nimport { ScopeEntry } from './Parser.type';\nimport { Runtime } from './Runtime';\nimport { ScopeChain } from './Scope';\nimport { add, div, divide, ensureNumbers, isFalse, mod, mul, strictDeepEqual, sub } from './utils';\n\nconst emptyScopeChain = new ScopeChain();\n\nexport class TreeInterpreter {\n  runtime: Runtime;\n  private _rootValue: JSONValue | null = null;\n  private _scope: ScopeChain;\n\n  constructor() {\n    this.runtime = new Runtime(this);\n    this._scope = new ScopeChain();\n  }\n\n  withScope(scope: ScopeEntry): TreeInterpreter {\n    const interpreter = new TreeInterpreter();\n    interpreter.runtime._functionTable = this.runtime._functionTable;\n    interpreter._rootValue = this._rootValue;\n    interpreter._scope = this._scope.withScope(scope);\n    return interpreter;\n  }\n\n  search(node: ExpressionNode, value: JSONValue): JSONValue {\n    this._rootValue = value;\n    this._scope = emptyScopeChain;\n    return this.visit(node, value) as JSONValue;\n  }\n\n  visit(node: ExpressionNode, value: JSONValue | ExpressionNode): JSONValue | ExpressionNode | ExpressionReference {\n    switch (node.type) {\n      case 'Ternary': {\n        const condition = this.visit(node.condition, value);\n        if (!isFalse(condition)) {\n          return this.visit(node.trueExpr, value);\n        }\n        return this.visit(node.falseExpr, value);\n      }\n      case 'Field':\n        const identifier = node.name;\n        if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n          return null;\n        }\n        // return the value of the field\n        return (value as JSONObject)[identifier] ?? null;\n      case 'LetExpression': {\n        const { bindings, expression } = node;\n        let scope = {};\n        bindings.forEach(binding => {\n          const reference = this.visit(binding, value) as JSONObject;\n          scope = {\n            ...scope,\n            ...reference,\n          };\n        });\n        return this.withScope(scope).visit(expression, value);\n      }\n      case 'Binding': {\n        const { variable, reference } = node;\n        const result = this.visit(reference, value);\n        return { [variable]: result } as JSONObject;\n      }\n      case 'Variable': {\n        const variable = node.name;\n        if (\n          !this._scope.getValue(variable) &&\n          !Object.prototype.hasOwnProperty.call(this._scope.currentScopeData, variable)\n        ) {\n          throw new Error(`Error referencing undefined variable ${variable}`);\n        }\n        return this._scope.getValue(variable);\n      }\n      case 'IndexExpression':\n        return this.visit(node.right, this.visit(node.left, value));\n      case 'Subexpression': {\n        const result = this.visit(node.left, value);\n        return result != null ? (this.visit(node.right, result) ?? null) : null;\n      }\n      case 'Index': {\n        if (!Array.isArray(value)) {\n          return null;\n        }\n        const index = node.value < 0 ? value.length + node.value : node.value;\n        return value[index] ?? null;\n      }\n      case 'Slice': {\n        if (!Array.isArray(value) && typeof value !== 'string') {\n          return null;\n        }\n        const { start, stop, step } = this.computeSliceParams(value.length, node);\n        if (typeof value === 'string') {\n          // string slices is implemented by slicing\n          // the corresponding array of codepoints and\n          // converting the result back to a string\n          const chars = [...value];\n          const sliced = this.slice(chars, start, stop, step);\n          return sliced.join('');\n        } else {\n          return this.slice(value, start, stop, step);\n        }\n      }\n      case 'Projection': {\n        const { left, right } = node;\n\n        // projections typically operate on arrays\n        // string slicing produces a 'Projection' whose\n        // first child is an 'IndexExpression' whose\n        // second child is an 'Slice'\n\n        // we allow execution of the left index-expression\n        // to return a string only if the AST has this\n        // specific shape\n\n        let allowString = false;\n        if (left.type === 'IndexExpression' && left.right.type === 'Slice') {\n          allowString = true;\n        }\n\n        const base = this.visit(left, value);\n        if (allowString && typeof base === 'string') {\n          // a projection is really a sub-expression in disguise\n          // we must evaluate the right hand expression\n          return this.visit(right, base) as JSONValue;\n        }\n\n        if (!Array.isArray(base)) {\n          return null;\n        }\n        const collected: JSONArray = [];\n        for (const elem of base) {\n          const current = this.visit(right, elem) as JSONValue;\n          if (current !== null) {\n            collected.push(current);\n          }\n        }\n        return collected as JSONValue;\n      }\n      case 'ValueProjection': {\n        const { left, right } = node;\n\n        const base = this.visit(left, value);\n        if (base === null || typeof base !== 'object' || Array.isArray(base)) {\n          return null;\n        }\n        const collected: JSONArray = [];\n        const values = Object.values(base);\n        for (const elem of values) {\n          const current = this.visit(right, elem) as JSONValue;\n          if (current !== null) {\n            collected.push(current);\n          }\n        }\n        return collected;\n      }\n      case 'FilterProjection': {\n        const { left, right, condition } = node;\n\n        const base = this.visit(left, value);\n        if (!Array.isArray(base)) {\n          return null;\n        }\n\n        const results: JSONArray = [];\n        for (const elem of base) {\n          const matched = this.visit(condition, elem);\n          if (isFalse(matched)) {\n            continue;\n          }\n          const result = this.visit(right, elem) as JSONValue;\n          if (result !== null) {\n            results.push(result);\n          }\n        }\n        return results;\n      }\n      case 'Arithmetic': {\n        const first = this.visit(node.left, value) as JSONValue;\n        const second = this.visit(node.right, value) as JSONValue;\n        switch (node.operator) {\n          case Token.TOK_PLUS:\n            return add(first, second);\n\n          case Token.TOK_MINUS:\n            return sub(first, second);\n\n          case Token.TOK_MULTIPLY:\n          case Token.TOK_STAR:\n            return mul(first, second);\n\n          case Token.TOK_DIVIDE:\n            return divide(first, second);\n\n          case Token.TOK_MODULO:\n            return mod(first, second);\n\n          case Token.TOK_DIV:\n            return div(first, second);\n\n          default:\n            throw new Error(`Syntax error: unknown arithmetic operator: ${node.operator}`);\n        }\n      }\n      case 'Unary': {\n        const operand = this.visit(node.operand, value) as JSONValue;\n        switch (node.operator) {\n          case Token.TOK_PLUS:\n            ensureNumbers(operand);\n            return operand as number;\n\n          case Token.TOK_MINUS:\n            ensureNumbers(operand);\n            return -(operand as number);\n\n          default:\n            throw new Error(`Syntax error: unknown arithmetic operator: ${node.operator}`);\n        }\n      }\n      case 'Comparator': {\n        const first = this.visit(node.left, value);\n        const second = this.visit(node.right, value);\n\n        // equality is an exact match\n\n        switch (node.name) {\n          case 'EQ':\n            return strictDeepEqual(first, second);\n          case 'NE':\n            return !strictDeepEqual(first, second);\n        }\n\n        // ordering operators are only valid for numbers\n\n        if (typeof first !== 'number' || typeof second !== 'number') {\n          return null;\n        }\n\n        switch (node.name) {\n          case 'GT':\n            return (first as number) > (second as number);\n          case 'GTE':\n            return (first as number) >= (second as number);\n          case 'LT':\n            return (first as number) < (second as number);\n          case 'LTE':\n            return (first as number) <= (second as number);\n        }\n      }\n      case 'Flatten': {\n        const original = this.visit(node.child, value);\n        return Array.isArray(original) ? original.flat() : null;\n      }\n      case 'Root':\n        return this._rootValue;\n      case 'MultiSelectList': {\n        const collected: JSONArray = [];\n        for (const child of node.children) {\n          collected.push(this.visit(child, value) as JSONValue);\n        }\n        return collected;\n      }\n      case 'MultiSelectHash': {\n        const collected: JSONObject = {};\n        for (const child of node.children) {\n          collected[child.name] = this.visit(child.value, value) as JSONValue;\n        }\n        return collected;\n      }\n      case 'OrExpression': {\n        const result = this.visit(node.left, value);\n        if (isFalse(result)) {\n          return this.visit(node.right, value);\n        }\n        return result;\n      }\n      case 'AndExpression': {\n        const result = this.visit(node.left, value);\n        if (isFalse(result)) {\n          return result;\n        }\n        return this.visit(node.right, value);\n      }\n      case 'NotExpression':\n        return isFalse(this.visit(node.child, value));\n      case 'Literal':\n        return node.value;\n      case 'Pipe':\n        return this.visit(node.right, this.visit(node.left, value));\n      case 'Function': {\n        const args: JSONArray = [];\n        for (const child of node.children) {\n          args.push(this.visit(child, value) as JSONValue);\n        }\n        return this.runtime.callFunction(node.name, args);\n      }\n      case 'ExpressionReference':\n        return {\n          expref: true,\n          ...node.child,\n        };\n      case 'Current':\n      case 'Identity':\n        return value;\n    }\n  }\n\n  computeSliceParams(arrayLength: number, sliceNode: SliceNode): { start: number; stop: number; step: number } {\n    let { start, stop, step } = sliceNode;\n\n    if (step === null) {\n      step = 1;\n    } else if (step === 0) {\n      const error = new Error('Invalid value: slice step cannot be 0');\n      error.name = 'RuntimeError';\n      throw error;\n    }\n\n    start = start === null ? (step < 0 ? arrayLength - 1 : 0) : this.capSliceRange(arrayLength, start, step);\n    stop = stop === null ? (step < 0 ? -1 : arrayLength) : this.capSliceRange(arrayLength, stop, step);\n\n    return { start, stop, step };\n  }\n\n  capSliceRange(arrayLength: number, actualValue: number, step: number): number {\n    let nextActualValue = actualValue;\n    if (nextActualValue < 0) {\n      nextActualValue += arrayLength;\n      if (nextActualValue < 0) {\n        nextActualValue = step < 0 ? -1 : 0;\n      }\n    } else if (nextActualValue >= arrayLength) {\n      nextActualValue = step < 0 ? arrayLength - 1 : arrayLength;\n    }\n    return nextActualValue;\n  }\n\n  slice(collection: JSONArray, start: number, end: number, step: number): JSONArray {\n    const result = [];\n    if (step > 0) {\n      for (let i = start; i < end; i += step) {\n        result.push(collection[i]);\n      }\n    } else {\n      for (let i = start; i > end; i += step) {\n        result.push(collection[i]);\n      }\n    }\n    return result;\n  }\n}\n\nexport const TreeInterpreterInstance = new TreeInterpreter();\nexport default TreeInterpreterInstance;\n","import { ExpressionNode } from './AST.type';\nimport { JSONValue } from './JSON.type';\nimport Lexer from './Lexer';\nimport { LexerOptions, LexerToken } from './Lexer.type';\nimport Parser from './Parser';\nimport { Options } from './Parser.type';\nimport {\n  BuiltInFunctionNames,\n  InputArgument,\n  InputSignature,\n  RegisterOptions,\n  RegistrationResult,\n  RuntimeFunction,\n} from './Runtime';\nimport { ScopeChain } from './Scope';\nimport TreeInterpreterInst from './TreeInterpreter';\n\nexport type { JSONArray, JSONObject, JSONPrimitive, JSONValue } from './JSON.type';\nexport type { Options } from './Parser.type';\nexport type {\n  BuiltInFunctionNames,\n  FunctionRegistry,\n  FunctionSignature,\n  InputSignature,\n  RegisterOptions,\n  RegistrationResult,\n  RuntimeFunction,\n} from './Runtime';\n\nexport const TYPE_ANY = InputArgument.TYPE_ANY;\nexport const TYPE_ARRAY = InputArgument.TYPE_ARRAY;\nexport const TYPE_ARRAY_ARRAY = InputArgument.TYPE_ARRAY_ARRAY;\nexport const TYPE_ARRAY_NUMBER = InputArgument.TYPE_ARRAY_NUMBER;\nexport const TYPE_ARRAY_OBJECT = InputArgument.TYPE_ARRAY_OBJECT;\nexport const TYPE_ARRAY_STRING = InputArgument.TYPE_ARRAY_STRING;\nexport const TYPE_BOOLEAN = InputArgument.TYPE_BOOLEAN;\nexport const TYPE_EXPREF = InputArgument.TYPE_EXPREF;\nexport const TYPE_NULL = InputArgument.TYPE_NULL;\nexport const TYPE_NUMBER = InputArgument.TYPE_NUMBER;\nexport const TYPE_OBJECT = InputArgument.TYPE_OBJECT;\nexport const TYPE_STRING = InputArgument.TYPE_STRING;\n\nexport function compile(expression: string, options?: Options): ExpressionNode {\n  const nodeTree = Parser.parse(expression, options);\n  return nodeTree;\n}\n\nexport function tokenize(expression: string, options?: LexerOptions): LexerToken[] {\n  return Lexer.tokenize(expression, options);\n}\n\n// Enhanced registerFunction with backward compatibility\nexport const registerFunction = (\n  functionName: string,\n  customFunction: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n  signature: InputSignature[],\n  options?: RegisterOptions,\n): void => {\n  TreeInterpreterInst.runtime.registerFunction(functionName, customFunction, signature, options);\n};\n\n// Enhanced registry functions with type safety\nexport const register = <T extends string>(\n  name: T extends BuiltInFunctionNames ? never : T,\n  customFunction: RuntimeFunction<(JSONValue | ExpressionNode)[], JSONValue>,\n  signature: InputSignature[],\n  options?: RegisterOptions,\n): RegistrationResult => {\n  return TreeInterpreterInst.runtime.register(name, customFunction, signature, options);\n};\n\nexport const unregisterFunction = <T extends string>(name: T extends BuiltInFunctionNames ? never : T): boolean => {\n  return TreeInterpreterInst.runtime.unregister(name);\n};\n\nexport const isRegistered = (name: string): boolean => {\n  return TreeInterpreterInst.runtime.isRegistered(name);\n};\n\nexport const getRegisteredFunctions = (): string[] => {\n  return TreeInterpreterInst.runtime.getRegistered();\n};\n\nexport const getCustomFunctions = (): string[] => {\n  return TreeInterpreterInst.runtime.getCustomFunctions();\n};\n\nexport const clearCustomFunctions = (): void => {\n  TreeInterpreterInst.runtime.clearCustomFunctions();\n};\n\nexport function search(data: JSONValue, expression: string, options?: Options): JSONValue {\n  const nodeTree = Parser.parse(expression, options);\n  return TreeInterpreterInst.search(nodeTree, data);\n}\n\nexport function Scope(): ScopeChain {\n  return new ScopeChain();\n}\n\nexport const TreeInterpreter = TreeInterpreterInst;\n\nexport const jmespath = {\n  compile,\n  registerFunction,\n  register,\n  unregisterFunction,\n  isRegistered,\n  getRegisteredFunctions,\n  getCustomFunctions,\n  clearCustomFunctions,\n  search,\n  tokenize,\n  TreeInterpreter,\n  TYPE_ANY,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n  TYPE_ARRAY,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_NUMBER,\n  TYPE_OBJECT,\n  TYPE_STRING,\n};\n\n// Export as default for backward compatibility\n// Supports both: import jmespath from '...' and import { jmespath } from '...'\nexport { jmespath as default };\n"]}